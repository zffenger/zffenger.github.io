<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring源码解析之ApplicationContext继承结构分析]]></title>
    <url>%2F2017%2FSpring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BApplicationContext%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[【原创文章，转载请注明出处】 在使用Spring的时候，我们经常需要先得到一个ApplicationContext对象，然后从该对象中获取我们配置的Bean对象。ApplicationContext隶属于org.springframework.context，是SpringFramework中Bean的管理者，为SpringFramework的诸多功能提供支撑作用。 下图是Spring-4.3.2.RELEASE版本中ApplicationContext相关的UML类视图（浅绿色的为接口，浅黄色的为类）： BeanFactory系列接口：1public interface BeanFactory BeanFactory 是 Spring 管理 Bean 的最顶层接口，是一个 Bean 容器, 管理一系列的 bean，每一个 bean 使用一个String 类型的 name(或称之为id) 来唯一确定，这些 Bean 可以是 prototype 的或者 singleton的 。Spring 提倡使用依赖注入(Dependency Injection) 的方式装配 Bean。BeanFactory从 configuration source 加载Bean的定义，configuration source 可以是xml文件或者properties文件甚至是数据库。1public interface HierarchicalBeanFactory extends BeanFactory BeanFactory的子接口HierarchicalBeanFactory是一个具有层级关系的Bean 工厂，拥有属性parentBeanFactory。当获取 Bean对象时，如果当前BeanFactory中不存在对应的bean，则会访问其直接parentBeanFactory 以尝试获取bean 对象。此外，还可以在当前的 BeanFactory 中 override 父级BeanFactory的同名bean。1public interface ListableBeanFactory extends BeanFactory ListableBeanFactory 继承了 BeanFactory， 实现了枚举方法可以列举出当前BeanFactory中所有的bean对象而不必根据name一个一个的获取。 如果 ListableBeanFactory 对象同时还是一个HierarchicalBeanFactory则getBeanDefinitionNames()方法只会返回当前BeanFactory中的Bean对象而不会去父级BeanFactory中查询。 其他接口：1public interface PropertyResolver 配置文件解析器的最顶级接口，解析配置文件获取属性值等作用1public interface Environment extends PropertyResolver 提供当前Application运行的所需环境1public interface EnvironmentCapable 这是一个Environment Holder，只有一个方法：Environment getEnvironment() 用来获取Environment对象1public interface ApplicationEventPublisher 该接口的功能是publish Event，向事件监听器（Listener）发送事件消息1public interface MessageSource 解析message的策略接口，方法形如: String getMessage(String, Object[], String, Locale)，用于支撑国际化等功能1public interface ResourcePatternResolver extends ResourceLoader 其中ResourceLoader用于从一个源（如InputStream等）加载资源文件，ResourcePatternResolver 是ResourceLoader的子类，根据path-pattern 加载资源。 ApplicationContext接口：1public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory, MessageSource, ApplicationEventPublisher, ResourcePatternResolver 重点来了，ApplicationContext接口继承众多接口，集众多接口功能与一身，为Spring的运行提供基本的功能支撑。根据程序设计的“单一职责原则”，其实每个较顶层接口都是“单一职责的”，只提供某一方面的功能，而ApplicationContext接口继承了众多接口，相当于拥有了众多接口的功能，下面看看它的主要功能： 首先，它是个BeanFactory，可以管理、装配bean，可以有父级BeanFactory实现Bean的层级管理（具体到这里来说它可以有父级的ApplicationContext，因为ApplicationContext本身就是一个BeanFactory。这在web项目中很有用，可以使每个Servlet具有其独立的context,所有Servlet共享一个父级的context），它还是Listable的，可以枚举出所管理的bean对象。 其次，它是一个ResourceLoader，可以加载资源文件； 再次，它可以管理一些Message实现国际化等功能； 还有，它可以发布事件给注册的Listener，实现监听机制。 ApplicationContext 的子接口：ApplicationContext 接口具有两个直接子接口，分别是： 12org.springframework.context.ConfigurableApplicationContextorg.springframework.web.context.WebApplicationContext 分别看这两个子接口: 1public interface ConfigurableApplicationContext extends ApplicationContext, Lifecycle, Closeable 根据接口名可以判决，该接口是可配置的！ApplicationContext 接口本身是 read-only 的，所以子接口 ConfigurableApplicationContext 就提供了如setID()、setParent()、setEnvironment()等方法，用来配置ApplicationContext。 再看其继承的另外两个接口： Lifecycle：Lifecycle接口中具有start()、stop()等方法，用于对context生命周期的管理； Closeable：Closeable是标准JDK所提供的一个接口，用于最后关闭组件释放资源等； 1public interface WebApplicationContext extends ApplicationContext 该接口仅仅在原接口基础上提供了getServletContext()，用于给servlet提供上下文信息。 1public interface ConfigurableWebApplicationContext extends WebApplicationContext, ConfigurableApplicationContext 这里 ConfigurableWebApplicationContext 又将上述两个接口结合起来，提供了一个可配置、可管理、可关闭的WebApplicationContext，同时该接口还增加了setServletContext()，setServletConfig()等set方法，用于装配WebApplicationContext。 到这里ApplicationContext相关接口基本上已经讲完了，总结起来就两大接口：12org.springframework.context.ConfigurableApplicationContextorg.springframework.web.context.ConfigurableWebApplicationContext 对于普通应用，使用ConfigurableApplicationContext 接口的实现类作为bean的管理者，对于web应用，使用ConfigurableWebApplicationContext 接口的实现类作为bean的管理者。这两个接口，从结构上讲他们是继承关系，从应用上讲他们是平级关系，在不同的领域为Spring提供强大的支撑。 ApplicationContext相关实现类设计：Spring是一个优秀的框架，具有良好的结构设计和接口抽象，它的每一个接口都是其功能具体到各个模块中的高度抽象，实际使用过程中相当于把接口的各个实现类按照接口所提供的组织架构装配起来以提供完整的服务，可以说掌握了Spring的接口就相当于掌握了Spring的大部分功能。 ApplicationContext 的实现类众多，上文中分析了 ApplicationContext 接口的各个功能，下面将分析 ApplicationContext 的实现类对上述接口的各个功能都是怎样实现的（PS. 限于篇幅，这里仅仅指出上述各个功能在实现类中什么位置通过什么方法实现，至于其具体实现过程，每一个功能拿出来都可以单独写一篇文章了，这里不进行详述）。至于实现类又扩展了其他接口或者继承了其他父类，这些只是实现类为了扩展功能或者为了对实现上述接口提供便利而做的事情，对ApplicationContext接口抽象出来的功能没有影响或者没有太大帮助，因此略去。 以ClassPathXmlApplicationContext为例，其主要继承关系如下： 123org.springframework.context.support.AbstractApplicationContext org.springframework.context.support.AbstractRefreshableApplicationContext org.springframework.context.support.AbstractRefreshableConfigApplicationContext org.springframework.context.support.AbstractXmlApplicationContext org.springframework.context.support.ClassPathXmlApplicationContext 而最顶层抽象类 AbstractApplicationContext 又实现了 ConfigurableApplicationContext 接口。1AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext, DisposableBean 根据上文所述，这里略去其父类 DefaultResourceLoader 和接口 DisposableBean ，只关注接口 ConfigurableApplicationContext，回忆一下该的主要功能： Configable, //可配置（该接口本身扩展的功能） Lifecycle, //生命周期可管理 Closeable，//可关闭（释放资源） EnvironmentCapable，//可配置Environment MessageSource, //可管理message实现国际化等功能 ApplicationEventPublisher, //可publish事件，调用Listener ResourcePatternResolver，//加载pattern指定的资源 ListableBeanFactory, HierarchicalBeanFactory, //管理Bean的生命周期，这个最重要，放最后说 然后回到最顶层抽象类 AbstractApplicationContext ，该抽象类可以说是 ClassPathXmlApplicationContext 继承结构中代码量最多的类， 上述的大部分功能也都在该类中实现。该类采用模板方法模式，实现了上述功能的大部分逻辑，然后又抽出许多protected方法（或 abstract方法）供子类override 。 各功能的实现列举如下： Configable：如setParent/setEnvironment等方法，由AbstractApplicationContext实现 。代码示例： 12345678910@Overridepublic void setParent(ApplicationContext parent) &#123; this.parent = parent; if (parent != null) &#123; Environment parentEnvironment = parent.getEnvironment(); if (parentEnvironment instanceof ConfigurableEnvironment) &#123; getEnvironment().merge((ConfigurableEnvironment) parentEnvironment); &#125; &#125;&#125; Lifecycle：AbstractApplicationContext拥有一个LifecycleProcessor实例，用于管理自身的生命周期，AbstractApplicationContext的Lifecycle方法如start、stop等由会代理给LifecycleProcessor进行处理，代码示例：12345@Overridepublic void start() &#123; getLifecycleProcessor().start(); publishEvent(new ContextStartedEvent(this));&#125; Closeable：由AbstractApplicationContext实现，用于关闭ApplicationContext销毁所有beans，此外如果注册有JVM shutdown hook，同样要将其移除 。代码示例：12345678910111213@Overridepublic void close() &#123; synchronized (this.startupShutdownMonitor) &#123; doClose(); if (this.shutdownHook != null) &#123; try &#123; Runtime.getRuntime().removeShutdownHook(this.shutdownHook); &#125;catch (IllegalStateException ex) &#123; // ignore - VM is already shutting down &#125; &#125; &#125;&#125; EnvironmentCapable：由AbstractApplicationContext实现，其持有一个ConfigurableEnvironment实例，用来实现EnvironmentCapable接口的getEnvironment方法 。代码示例：1234567@Overridepublic ConfigurableEnvironment getEnvironment() &#123; if (this.environment == null) &#123; this.environment = createEnvironment(); &#125; return this.environment;&#125; MessageSource：AbstractApplicationContext持有一个MessageSource实例，将MessageSource接口的方法代理给该实例来完成 。代码示例：1234@Overridepublic String getMessage(String code, Object args[], String defaultMessage, Locale locale) &#123; return getMessageSource().getMessage(code, args, defaultMessage, locale);&#125; ApplicationEventPublisher：由AbstractApplicationContext实现，如果存在父级ApplicationContext，则同样要将event发布给父级ApplicationContext。代码示例：1234567891011@Overridepublic void publishEvent(ApplicationEvent event) &#123; Assert.notNull(event, "Event must not be null"); if (logger.isTraceEnabled()) &#123; logger.trace("Publishing event in " + getDisplayName() + ": " + event); &#125; getApplicationEventMulticaster().multicastEvent(event); if (this.parent != null) &#123; this.parent.publishEvent(event); &#125;&#125; ResourcePatternResolver：AbstractApplicationContext持有一个ResourcePatternResolver实例，该接口的方法代理给该实例完成 。代码示例：1234@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123; return this.resourcePatternResolver.getResources(locationPattern);&#125; ListableBeanFactory, HierarchicalBeanFactory： AbstractApplicationContext 间接实现了这两个接口， 然而却并没有实现任何BeanFactory的任何功能。AbstractApplicationContext 拥有一个 ConfigurableListableBeanFactory实例，所有BeanFactory的功能都代理给该实例完成。代码示例：12345@Overridepublic Object getBean(String name) throws BeansException &#123; assertBeanFactoryActive(); return getBeanFactory().getBean(name);&#125; 而AbstractApplicationContext 的getBeanFactory() 方法是一个抽象方法，即由子类来提供这个BeanFactory。代码示例：12@Overridepublic abstract ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException; 在 ClassPathXmlApplicationContext 的继承体系中， 类AbstractRefreshableApplicationContext实现了这个 getBeanFactory()方法。这里getBeanFactory()方法会创建一个DefaultListableBeanFactory实例作为返回值。 小结本文以 Spring Framework 的 ApplicationContext 为中心，分析了 ApplicationContext 的机构体系和功能实现。接口 ApplicationContext 继承了众多接口，可以满足应用中“面向接口编程”的常用功能需求。抽象类 AbstractApplicationContext 实现了ApplicationContext 接口中简单不易变动的部分，然后通过“组合”将众多“容易变动”功能代理给它的一些成员变量来实现，最后再使用模板方法模式让子类为父类提供一些函数的支持或者设置替换父类的上述成员变量，从而实现了“对扩展开放，对修改封闭”的设计原则，为Spring Framework 提供了灵活性大可扩展性强的架构支撑。 【原创文章，转载请注明出处】]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>Spring源码解析</tag>
        <tag>源码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程之多线程的创建与同步]]></title>
    <url>%2F2017%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E5%90%8C%E6%AD%A5.html</url>
    <content type="text"><![CDATA[线程是一个单独的执行体。初学者往往分不清线程和任务，通常所说的创建一个线程，比如写一个实现Runnable接口的类或者继承Thread重写run()方法的类，通常是指创建一个被单独线程执行的任务，真正线程的创建时在调用Thread.start()方法开始的。 多线程的创建与任务的执行记住，线程是一个具有执行能力的资源，我们的任务要使用该资源完成自身的执行过程。我们要做的就是创建一些任务（根据具体业务需要），再创建一些线程来执行这些任务。当然，可以先创建任务，再使用任务创建线程。比如实现Runnable接口的类或者继承Thread重写run()方法，然后通过start()方法创建线程并执行任务。这样的线程执行完run()方法中的任务后就退出，是一次性的。123456789101112131415161718192021222324252627282930public class Demo &#123; public static void main(String[] args) &#123; //create three Thread Thread t1=new Thread(new demo1());//使用Runnable创建 Thread t2=new demo2();//使用Thread子类创建 Thread t3=new Thread(new Runnable()&#123;//使用匿名内部类创建 public void run()&#123;printFun();&#125; &#125;); //start the thread t1.start(); t2.start(); t3.start(); &#125; public static void printFun()&#123; System.out.println(Thread.currentThread().getName() +" run print function"); &#125;&#125;class demo1 implements Runnable&#123; @Override public void run() &#123; Demo.printFun(); &#125;&#125;class demo2 extends Thread&#123; @Override public void run() &#123; Demo.printFun(); &#125;&#125; 也可以把线程和任务分开创建。使用线程池，创建独立于任务的一些类线程，然后把任务提交给线程池执行。线程池中的线程是可以反复利用的，执行完提交的前一个任务再去取出任务队列中的后续任务进行执行。12345678910111213141516171819202122public class DemoThreadPool &#123; public static void main(String[] args) &#123; int threadCount=3;//线程池中线程数量 //创建线程池 ExecutorService threadPool = Executors.newFixedThreadPool(threadCount); //循环创建10个任务并提交线程池执行 for(int i=0; i&lt;10; ++i)&#123; //任务编号 final int currentTaskNum=i; //创建任务 Runnable task=new Runnable()&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+" execute task "+currentTaskNum); &#125; &#125;; //提交执行 threadPool.submit(task); &#125; threadPool.shutdown(); &#125;&#125; 使用线程池情况下，除了Runnable外还有另一个接口供我们创建任务，即Callable接口。任务示例如下：123456789101112131415161718192021222324252627282930public class DemoThreadPool &#123; public static void main(String[] args) throws Exception &#123; int threadCount=3; //线程池 ExecutorService threadPool = Executors.newFixedThreadPool(threadCount); //存放任务执行后的返回结果 List&lt;Future&lt;String&gt;&gt; results=new ArrayList&lt;&gt;(); for(int i=0; i&lt;10; ++i)&#123; final int currentTaskNum=i; //创建任务 Callable&lt;String&gt; task=new Callable&lt;String&gt;()&#123; @Override public String call() throws Exception &#123; // 任务代码 System.out.println("task "+currentTaskNum); return "task "+currentTaskNum+" done"; &#125; &#125;; //提交任务 Future&lt;String&gt; result = threadPool.submit(task); results.add(result); &#125; //取出任务执行结果并打印 for(Future&lt;String&gt; ret : results)&#123; System.out.println(ret.get()); &#125; //关闭线程池 threadPool.shutdown(); &#125;&#125; 与Runnable不同的是Callable接口运行任务执行过程中抛出受检异常，也允许有返回值。返回值使用Future接口，代表未来的的某个时候（具体指该任务执行完成以后）可以取出任务执行的结果（返回值）。 多线程同步与通信大多数情况下，任务之间都是相互关联的。多个任务再多线程中执行，线程之间需要一定的通信机制来保证任务的协同性。另外，有一些数据是可供多个线程同时访问的，这种访问包括读取和改写，如果一个线程在写数据的同时有另外的线程在读数据，则会破坏线程间的数据一致性，可能读取到难以理解的“脏数据”！因此多线程之间的共享变量需要同步来保证多线程对数据访问的顺序性。最常见的多线程通信的例子就是 生产者—消费者 模式，生产者可以是一个或多个，消费者也可以是一个或多个。先来看单生产者—消费者模式的例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ProducerConsumer &#123; public static void main(String[] args) &#123; final ProducerConsumerDemo demo = new ProducerConsumerDemo(); //简洁起见这里使用Lambda表达式吧，Java8都出来这么久了，这个你应该掌握 Runnable producer = ()-&gt;demo.produce(); Runnable consumer = ()-&gt;demo.comsume(); //启动线程 new Thread(producer).start(); new Thread(consumer).start(); &#125;&#125;class ProducerConsumerDemo &#123; private static final int loopTime = 10;//循环次数 private volatile boolean hasData = false; //标志位 private Data data; //生产者消费者交换数据 public void produce() &#123; for (int i = 0; i &lt; loopTime; ++i) &#123; synchronized (this) &#123; while (hasData) &#123; try &#123; wait(); //如果已经有数据，则生产者线程等待消费者线程把数据消费掉之后再生产 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); return; &#125; &#125; data = new Data();//生产 data.value = i; hasData = true; //改变标志位 System.out.println("producer produce a data: " + data.value); notify(); //唤醒消费者线程来取数据 &#125; &#125; &#125; public void comsume() &#123; for (int i = 0; i &lt; loopTime; ++i) &#123; synchronized (this) &#123; while (!hasData) &#123; try &#123; wait();//如果没有数据则等待生产者线程生产数据 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); return; &#125; &#125; int value = data.value; hasData = false; //消费数据 System.out.println("consumer consume a data: " + value); notify();//唤醒生产者线程进行下一次生产 &#125; &#125; &#125;//存放数据的JavaBean static class Data &#123; public int value; &#125;&#125; 如果存在多个生产者多个消费者，则应该把代码中的 notify()改为notifyAll()。因为这里所有的生产者消费者都阻塞在监视器对象this上，notify的作用是随机唤醒一个等待该监视器对象的线程，如果一个生产者恰巧唤醒了另一个生产者线程，后面的生产者线程检查 hasData ，有数据，不能进行生产，那就继续 wait下去，这样所有的线程都在wait , 就是一个死锁状态了！如果是 notifyAll 则唤醒所有阻塞在该监视器上的线程，这样如果生产者线程获得锁查看有数据，进入wait状态，而消费者线程继而获取监视器锁并进行消费。造成这种状况的根本原因是生产者消费者线程都部分彼此的排在同一个等待队列中，从而唤醒的时候不知道唤醒的是生产者还是消费者。Java的concurrent包给我们提供了一种新型的锁，可以做到将生产者和消费者排在不同的队列（Condition）上，这样就可以有针对性的唤醒线程，既简化了编程，又提高了效率。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class ProducerConsumerDemo &#123; private static final int loopTime = 10; private volatile boolean hasData = false; private Data data; private final Lock lock=new ReentrantLock(); private final Condition producerCondition=lock.newCondition(); private final Condition consumerCondition=lock.newCondition(); public void produce() &#123; for (int i = 0; i &lt; loopTime; ++i) &#123; try &#123; lock.lock(); while (hasData) &#123; try &#123; //继续等待 producerCondition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); return; &#125; &#125; data = new Data(); data.value = i; hasData = true; System.out.println("producer produce a data: " + data.value); //唤醒消费者线程 consumerCondition.signal(); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125; public void comsume() &#123; for (int i = 0; i &lt; loopTime; ++i) &#123; try&#123; lock.lock(); while (!hasData) &#123; try &#123; //继续等待 consumerCondition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); return; &#125; &#125; int value = data.value; hasData = false; System.out.println("consumer consume a data: " + value); //唤醒生产者线程 producerCondition.signal(); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125;//存放数据 static class Data &#123; public int value; &#125;&#125; 无论是使用JVM内置锁对象的 wait / nofity / nofityAll 还是Lock/Condition对象的await / signal / signalAll 方法实现生产者消费者模式都不是一个好的办法。这样的做法既复杂又容易出错，我们应该尽可能的用现有存在的同步工具来实现需要的功能。比如用BlockQueue来实现生产者—消费者模式将会简单很多：123456789101112131415161718192021222324252627282930313233class BlockedProducerConsumerDemo &#123; private static final int loopTime = 10; private final BlockingQueue&lt;Data&gt; queue = new ArrayBlockingQueue&lt;&gt;(1); public void produce() &#123; for (int i = 0; i &lt; loopTime; ++i) &#123; try &#123; Data data = new Data(); data.value = i; queue.put(data); //将数据放入队列中 System.out.println("producer produce a data: " + data.value); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public void comsume() &#123; for (int i = 0; i &lt; loopTime; ++i) &#123; try &#123; Data data = queue.take(); //从队列中取出数据 int value = data.value; System.out.println("consumer consume a data: " + value); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static class Data &#123; public int value; &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计模式之单例模式]]></title>
    <url>%2F2017%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。 单例（Singleton）模式是在Java代码中使用频率非常高的一种设计模式。提到设计模式，可能很多人第一个想到的就是单例模式。单例模式要实现的效果是在全局范围内只有一个实例对象，用该实例对象管理其他对象或者一些资源的话就相当于在全局范围内有一个唯一的管理者，能够使代码结构更加清晰。 设计模式本身是不区分编程语言的，它是一种通用的良好的设计思路。然而不同编程语言又具有自身的特点，因而在对设计模式的实现上可能具有一些特有的“个性”，这一点在单例模式的Java实现中尤为明显，特别是针对多线程访问的情况。 最简单的单例模式code-1: 12345678910class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; //私有化构造函数 public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 将构造函数私有化，以保证无法再外部构造该对象。使用一个静态方法，先检查对象是否为空然后构造对象实例来保证对象唯一。这种“先检查后执行”的办法称为“Check-Then-Act”操作，在Java并发编程中这是一个常见的“竞态条件（Race Condition）”，即在多线程情况下由于一些可能的线程执行顺序导致错误的结果。也就是线程不安全的。 线程安全的单例模式要想得到线程安全的单例，常见的有两种做法。第一种也就是加上一个互斥锁，保证多线程在临界区的顺序性，如下（注意synchronized关键字）：code-2: 12345678910class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 另一种做法就是在所有线程能够访问对象实例之前完成对象的构造过程，保证所有线程能够访问该对象时对象已经构造完成。也就是著名的饿汉式！code-3: 1234567class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return instance; &#125;&#125; 一种更好的改进上面的两种线程安全的单例实现都有一定的不足之处： 第一种，每次获取单例对象都要先获取锁，得到单例对象后释放锁。由于锁的互斥性，多个线程获取单例对象时只能排队依次获取，效率低下； 第二种，类加载时就要完成对象构造，由于类加载的时机不容易控制，再者如果对象构造比较耗时而我们又希望系统能够快速启动，这些情况都不是我们希望的。 选择性加锁，双重检查的单例实现code-4: 1234567891011121314class Singleton &#123; private volatile static Singleton singleton; private Singleton() &#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 上面代码相当于在code-2 的基础上加上了空值判断，只有在判断实例对象为空时才加锁并构造对象，后续对象已存在的情况下就不会再进入加锁的同步代码块，有效提高了并发效率。注意上面代码中的volatile关键字，该关键字在上述代码中必不可少，否则这个单例的类并不是线程安全的。Java中构造一个对象并将一个指向该对象的引用保存在其他代码可以访问的地方称为“对象发布（Publish）”，如果在对象构造完成之前发布该对象就会破坏线程的安全性。new一个对象需要多步操作，现代处理器可能将这多步操作顺序进行重排序以提高并行度。比如：123456789101112singleton = new Singleton();//假如上述语句可以分解为如下4条指令operation 1: //malloc memoryoperation 2: //init property p1operation 3: //init property p2operation 4: //set singleton point to the memory//则实际的执行顺序可能可能是：operation 1: //malloc memoryoperation 2: //init property p1operation 4: //set singleton point to the memoryoperation 3: //init property p2//上面operation 4发布对象，而这时operation 3还未执行，这就是一个不完整的对象 上面示例展示了一种不安全的发布对象的方式，这时重排序造成的。当然这种重排序 在单线程情况下是安全的，这时Java内存模型保证的。在多线程情况下，后一个线程可能取得前一个线程未构造完成的对象。Java中volatile关键字可以保证对象的构造不逸出构造函数之外，因而能够保证如果后一条线程能够取得对象引用，那么对象一定是构造完成的，从而保证了该对象的线程安全性。 一种取巧的方法前面提到过，饿汉式单例实现使用类加载器完成对象构造，对象构造的时机不易控制，如果能解决这个问题呢？123456789class Singleton &#123; private static class InstanceHolder &#123; private static final Singleton instance= new Singleton(); &#125; private Singleton() &#123;&#125; public static final Singleton getInstance() &#123; return InstanceHolder.instance; &#125;&#125; 使用内部类，内部类并不随着外部类的加载而被加载。只有调用getInstance()方法是，内部类才被加载，此时对象才被构造。因为类加载过程是线程安全的，因为这种实现方式是线程安全的。 还可能面临的问题以及解决办法上面的线程安全的单例实现已经可以满足大多数情况下的需求了，但是还存在一些更加“变态”的情况可以将上述单例搞出多个实例来。 Java的类是通过类加载器ClassLoader加载类到内存中的，普通情况下的Classloader使用双亲委托机制，能够保证被加载类的唯一性。然而Web服务器为了隔离多个web应用，打破了这种机制，使用自定义类加载器优先的方式加载类。Web服务器一般使用多个类加载器加载类，甚至为每个Servlet分配一个类加载器。这种情况下两个不同的Servlet访问一个单例，单例类可能被加载两次，就产生了两个对象，这就破坏了单例的语义。解决办法就是使用同一个ContextClassLoader绑定在线程上，使用ContextClassLoader加载单例类。 单例类可能实现了Serialable接口，重复的序列化/反序列化可以复制出多个相同的对象。此外还可以通过反射构造出多个对象。着也称为序列化攻击和反射攻击。对于这种情况， 《Effective Java》上推荐一种方式，即用枚举构造单例，具有抗序列化攻击和反射攻击的能力。123456enum Singleton &#123; INSTANCE; public void methodA() &#123;&#125; public void methodB() &#123;&#125; //any method for this instance&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetty入门指南]]></title>
    <url>%2F2017%2FJetty%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97.html</url>
    <content type="text"><![CDATA[Jetty简介：Jetty是一个优秀的Servlet引擎，一个著名的java开源项目，隶属于Eclipse基金会。相比于tomcat，Jetty更加轻量级也更加灵活，它使用Handler作为基本数据模型，所有的扩展性组件都可以以Handler的形式添加到Server中，因此非常容易实现定制化和功能扩展。Jetty是模块化设计的，使用Jetty的时候可以选择性的使用一些组件而禁用一些不必要的组件来减少内存的占用；Jetty的名言： Don’t deploy your application in Jetty, deploy Jetty in your application 也说明了Jetty部署的灵活性。目前Jetty的最新稳定版是9.3，发布于2015年，支持Servlet 3.1和JSP 2.3标准，支持HTTP/1.1 (RFC 7230), HTTP/2 (RFC 7540), WebSocket (RFC 6455, JSR 356), FastCGI等协议标准。 下载Jetty下载Jetty：https://www.eclipse.org/jetty/download.html 最新稳定版是 9.3.11.v20160721下载 .zip 文件，解压。得到如下目录结构，各目录/文件说明如下： bin/ 含有 .sh 脚本工具，用于Unix类系统上运行Jettydemo-base/ 运行demo程序的一个目录etc/ Jetty的XML配置文件目录lib/ Jetty运行所需的所有Jar文件都在改目录logs/ log目录modules/ 定义Jetty模块的目录resources/ Jetty所需的一些资源文件目录，如log4j的配置文件webapps/ Jetty默认配置下的webapp目录lincese-eplv10-aslv20.html Jetty的Lincese文件notice.html 注意事项README.TXT Jetty使用简介start.ini 启动配置文件start.jar Jetty启动入口程序VERSION.TXT 版本信息 启动Jetty在上述解压的目录中打开命令行，使用 Java –jar start.jar 即可启动jetty。打开浏览器访问http://localhost:8080，可以看到 404 错误页面,证明Jetty启动成功。回到命令行窗口，查看启动过程中的信息提出，其中会有这么一个警告: WARN:oejs.HomeBaseWarning:main: This instance of Jetty is not running from a separate {jetty.base} directory, this is not recommended. See documentation at http://www.eclipse.org/jetty/documentation/current/startup.html 这里将Jetty解压出来的根目录称为 $JETTY_HOME，这个警告信息提示：不建议在$JETTY_HOME直接启动Jetty。根据官方文件，Jetty建议使用一个独立的目录独立的配置文件启动Jetty，下文将这个独立的目录称为 JettyBase。 下文中的命令都是Linux下的命令，如果是Windows请自行替换，如Windows下的环境变量用%var%而不是$var，拷贝命令是copy而不是cp 上面展示Jetty的目录结构中有一个demo-base目录，现在将这个目录作为Jetty Base目录，进入该目录，在这个目录启动Jetty：java -jar $JETTY_HOME/start.jar然后再访问http://localhost:8080 即可看到Jetty的欢迎页面。 配置Jetty前文提到，Jetty是模块化设计的，使用Jetty时我们可以有选择的启动或者禁用一些模块。查看当前$JETTY_BASE的模块信息：12345//列出所有的模块和当前已启用的模块以及模块的依赖关系等信息cd $JETTY_HOME/demo-base/java -jar $JETTY_HOME/start.jar --list-modules//查看当前$JETTY_BASE的配置信息：java -jar %JETTY_HOME/start.jar --list-config 创建一个新的JettyBase一个Jetty Base 目录可以为Jetty服务器提供一份独立的运行环境和配置信息。Jetty服务器默认配置有以下两个属性： jetty.home 该属性定义了Jetty 部署的位置信息，包括libs，默认开启模块信息、默认XML配置等 jetty.base 该属性定义了一个特定服务器实例的位置信息，包括它的配置、webapp、logs等信息. 上述两个属性都可以通过命令行进行设置和查看。对应环境变量$JETTY_HOME和$JETTY_BASE。 使用以下命令可以创建一个Jetty Base目录，并向该JettyBase添加HTTP模块和deploy模块。 1234567JETTY_BASE=/tmp/mybasemkdir $JETTY_BASEcd $JETTY_BASEjava -jar $JETTY_HOME/start.jar --add-to-startd=http,deploy// 从demo-base拷贝webapp到该JettyBase并启动Jetty。cp $JETTY_HOME/demo-base/webapps/async-rest.war webapps/ROOT.warjava -jar $JETTY_HOME/start.jar 指定Jetty启动端口java -jar $JETTY_HOME/start.jar jetty.http.port=8081此外，还可以start.ini或者start.d/http.ini配置文件中指定端口jetty.http.port信息。 start.d/http.ini文件中的所有配置都将作为http模块的命令行参数传入。 http模块modules/http.mod文件指定了http模块的定义xml文件（etc/jetty-http.xml）和http模块的参数模块（http.ini） etc/jetty-http.xml文件根据参数jetty.http.port属性想HttpContector注入端口信息。 启用https和http2启用https和http2，启动jetty并配置端口为84441234//添加模块java -jar $JETTY_HOME/start.jar --add-to-startd=https,http2//启动Jetty并指定端口java -jar $JETTY_HOME/start.jar jetty.ssl.port=8444 –add-to-startd 参数会将配置信息加入start.d目录下对应文件中 –add-to-start 参数会将配置信息加入 start.ini 文件中 使用命令java -jar $JETTY_HOME/start.jar –help 获取帮助信息 Jetty部署web项目Jetty Server启动后会检查 JettyBase/webapps目录下的webapp并自根据配置自动部署webapp。 Deploy说明： 对目录的部署：如果webapps目录下有example/目录，Jetty会在example目录下寻找WEB-INF/目录，如果存在该目录则会将该app部署为标准webapp，如果不存在则部署为静态web项目。可以通过http://localhost:8080/example访问。如果目录名以 .d 结尾（如example.d目录）则忽略该目录（不进行deploy）。 对war包的部署：如果webapps目录下存在example.war，则对war包进行解压并部署，如果同时存在example.war和example/目录，则只部署example.war。 对xml文件的部署：如果存在example.xml，则根据该xml文件的配置进行部署，xml文件必须配置context path。如果同时存在example.xml，example.war和example/目录，则xml文件的部署优先级最高，同名的war包和目录会被部署器忽略。 对于ROOT/目录或者ROOT.war则部署之后的Contextpath为“/”(war包优先部署)]]></content>
      <tags>
        <tag>jetty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORMLite使用指南]]></title>
    <url>%2F2017%2FORMLite%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.html</url>
    <content type="text"><![CDATA[ORMLite是一款优秀的轻量级的ORM框架，常用于Android平台，但它并不是 Android 平台专用的ORM框架，它也可用于普通的Java环境中。 ORMLite除了支持Sqlite外还支持MySQL, Postgres, Microsoft SQL Server, H2, Derby, HSQLDB等数据库。支持JDBC连接，Spring以及Android平台。语法中广泛使用了注解（Annotation）。 必须的jar包：ORMLite的核心包是ormlite-core.jar，在普通的java环境中使用还需要添加ormlite-jdbc.jar，在Android环境中使用则需要ormlite-android.jar。 可选的jar包：(Log包)Apache commons logging,，Log4j，Android Log 等ORMLite启动后log代码会在classpath中依次查找android.util.Log、org.apache.commons.logging.LogFactory、org.apache.log4j.Logger等，如果找到前一个则不再继续查找。如果这几个类都不存在，ORMLite则使用自身内置的log代码记录日志。 本文以普通java环境中ORMLite的使用为例展示ORMLite的常用技巧和注意事项。ORMLite在Android环境中的使用与普通java环境中的使用基本一致，不同的是数据源以及配置的不同，而且Android环境中ormlite-android.jar提供了一些特定的工具类，使用起来更加方便，具体请参见官网：http://ormlite.com/。 入门示例ORMLite的使用非常简单，先看一个入门代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142@DatabaseTable(tableName = "accounts")public class Account &#123; @DatabaseField(id = true) private String name; @DatabaseField(canBeNull = false) private String password; Account() &#123; // 必须有一个无参数构造函数 &#125; Account(String name, String pwd) &#123; this.name=name; this.password=pwd; &#125; &#125;```java// 数据库urlString databaseUrl = "jdbc:h2:mem:account";// 创建一个数据库连接ConnectionSource connectionSource = new JdbcConnectionSource(databaseUrl);// 创建DAO对象Dao&lt;Account,String&gt; accountDao = DaoManager.createDao(connectionSource, Account.class);// 创建表（视需求而定）TableUtils.createTable(connectionSource, Account.class);// 创建实体对象String name = "Jim Smith";Account account = new Account(name, "_secret");// 持久化到数据库accountDao.create(account);// 从数据库中查询Account account2 = accountDao.queryForId(name);System.out.println("Account: " + account2.getPassword());// 关闭连接池connectionSource.close(); ORMLite中注解的使用ORMLite使用注解标明实体字段与数据库表字段的对应关系。注解既可使用ORMLite的注解，如 @DatabaseTable，@DatabaseField等；也可使用javax.persistence的注解，如@Entity、@Id、@Column等 比如：12345678@DatabaseTable(tableName = "accounts") public class Account &#123; @DatabaseField(id = true) private String name; @DatabaseField(canBeNull = false) private String password; // …&#125; 等价于12345678@Entity(name = "accounts") public class Account &#123; @Id private String name; @Column(nullable = false) private String password; // … &#125; 注意事项： 实体类必须有一个无参构造函数，有get/set方法 ORMLite连接池的使用ORMLite对连接池做了一层封装，使用com.j256.ormlite.support.ConnectionSource接口表示。ConnectionSource接口的实现类有JdbcConnectionSource、JdbcPooledConnectionSource、DataSourceConnectionSource等，分别代表单个连接的连接池、jdbc可复用连接池、数据源连接池等。 示例如下：12345678910111213final String url="jdbc:h2:mem:account";// 单个连接的连接池ConnectionSource jdbcconnectionSource = new JdbcConnectionSource(url);// 带缓存的连接池JdbcPooledConnectionSource pooledconnectionSource = new JdbcPooledConnectionSource(url);// 数据源BasicDataSource dataSource = new BasicDataSource();dataSource.setUrl(url);// 数据源连接池ConnectionSource dsconnectionSource = new DataSourceConnectionSource(dataSource, url); 注意事项： DataSource接口没有close方法，因而调用DataSourceConnectionSource的close方法其实什么也没做，DataSource需要我们手动关闭。 JdbcConnectionSource不是线程安全的，不能用在多线程环境中 ORMLite中DAO的创建Data Access Object (DAO) 可以使用DaoManager.createDao方法创建，也可以继承BaseDaoImpl类创建具有额外功能的自定义DAO。示例如下：12345678910111213141516//使用DaoManager创建Dao,泛型第一个参数为实体类，第二个参数为主键类 Dao&lt;User, Integer&gt; userDao = DaoManager.createDao(connectionSource, User.class);自定义DAO/** 继承BaseDaoImpl实现自定义DAO类 */ public class UserDaoImpl extends BaseDaoImpl&lt;User, Integer&gt;&#123; public UserDaoImpl(ConnectionSource connectionSource) throws SQLException &#123; super(connectionSource, User.class); &#125; &#125;//在实体类上用注解标明自定义DAO的类文件@DatabaseTable(daoClass = UserDaoImpl.class) public class Account &#123; //… &#125; 注意事项： 创建DAO的开销比较大，尽量将DAO重复利用。DaoManager具有缓存功能，可以将创建的DAO缓存下来，避免重复创建，因此尽量使用DaoManager创建DAO ORMLite使用DAO进行增删改查操作ORMLite框架的DAO接口为用户提供了丰富的CRUD操作的重载方法。 CRUD示例：1234567891011//构造JavaBeanUser u=new User(111,"ormlite_111");//插入数据userDao.create(u);//更新u1.setName("ormlite_111_updated");userDao.update(u); //查询User uq = userDao.queryForId(111);//删除userDao.delete(u); 注意事项：查询、更新、删除操作要求实体类标明主键（id） ORMLite的DAO接口还是可迭代的。可以通过Dao接口遍历一张数据表。示例如下： 123for (Account account : accountDao) &#123; System.out.println(account.getName()); &#125; 注意事项：Dao接口的循环迭代要求迭代完全部而不能中途返回（比如for循环中有return语句），否则迭代器不会被关闭从而造成资源泄露 也可以使用显式的迭代器，确保手动关闭迭代器资源，如下： 12345678910CloseableIterator&lt;Account&gt; iterator = accountDao.closeableIterator();try &#123; while (iterator.hasNext()) &#123; Account account = iterator.next(); System.out.println(account.getName()); &#125;&#125; finally &#123; // close it at the end to close underlying SQL statement iterator.close();&#125; DAO Enabled 实体 ORMLite允许实体类自身具有类似Dao的功能，通过继承BaseDaoEnabled类实现。示例：12345678@DatabaseTable(tableName = "t_test")public class User extends BaseDaoEnabled&lt;User, Object&gt; &#123; @DatabaseField(id = true) private int id; @DatabaseField(canBeNull = false) private String name;// …&#125; CRUD操作如下： 123456User u=new User();u.setDao(userDao);u.create();//insertu.refresh();//query the new datau.update();//updateu.delete();//delete ORMLite中数据库与表的创建ORMLite提供一些工具类用于创建和销毁Schema和table。 TableUtils类： 根据实体类直接创建表TableUtils.createTable(connectionSource, Account.class);根据config创建表 1234567DatabaseFieldConfig dfc=new DatabaseFieldConfig();// dfc.setColumnName("name");List&lt;DatabaseFieldConfig&gt; fieldConfigs = Arrays.asList(dfc);DatabaseTableConfig&lt;Account&gt; tableConfig = new DatabaseTableConfig&lt;Account&gt;(Account.class, fieldConfigs);// 创建表TableUtils.createTable(connectionSource, tableConfig); 如果没有则创建TableUtils.createTableIfNotExists(connectionSource, tableConfig);删除表TableUtils.dropTable(ConnectionSource, Class, boolean ignoreErrors); 这些创建、删除表的操作对测试非常方便，可以在测试类中创建表、删除表等 ORMLite对原生SQL支持ORMLite定义的Dao功能并不保证覆盖所有的SQL操作，比如sum、count、avg等函数功能，因而ORMLite提供了对原生SQL的支持。 查询操作示例： 12GenericRawResults&lt;String[]&gt; rawResults =accountDao.queryRaw("select count(*) from t_test where id &lt; 10"); 还可以使用QueryBuilder构建prepareStatement查询： 123QueryBuilder&lt;Account, Integer&gt; qb = accountDao.queryBuilder();qb.where().gt("orderCount", 10);GenericRawResults&lt;String[]&gt; results = accountDao.queryRaw(qb.prepareStatementString()); 带参数的prepareStatement查询 123QueryBuilder&lt;Account, Integer&gt; qb = accountDao.queryBuilder();qb.where().lt("orderCount", new SelectArg());GenericRawResults&lt;String[]&gt; results = accountDao.queryRaw(qb.prepareStatementString(), "10"); 查询结果自动映射到对象 123456789101112// 传入映射对象GenericRawResults&lt;User&gt; rawResults = userDao.queryRaw( "select id,name from t_test order by id", new RawRowMapper&lt;User&gt;() &#123; public User mapRow(String[] columnNames, String[] resultColumns) &#123; return new User(Integer.parseInt(resultColumns[0]),resultColumns[1]); &#125; &#125;); // 取出映射结果 for (User u : rawResults) &#123; System.out.println(u); &#125; rawResults.close(); 注意事项： rawResults是可迭代的，迭代全部结果集后会自动关闭，否则结果集最后必须手动关闭； 使用prepareStatement查询时，如果查询字段中没有id字段，则QueryBuilder会自动添加上去，因此查询结果可能会比预想的多一列。 更新示例：（包括Insert，Update，Delete）userDao.updateRaw(&quot;INSERT INTO t_test (id, name) VALUES(111,Lee)&quot;); ORMLite使用QueryBuilder构建高级查询使用ORMLite的QueryBuilder可以构建类似于原生SQL的自定义查询，而且使用更加方便。 示例1：（where条件查询） 123456QueryBuilder&lt;Account, Object&gt; queryBuilder = accountDao.queryBuilder();Where&lt;Account, Object&gt; where = queryBuilder.where();where.eq(Account.NAME_FIELD_NAME, &quot;foo&quot;);where.and();where.eq(Account.PASSWORD_FIELD_NAME, &quot;_secret&quot;);PreparedQuery&lt;Account&gt; preparedQuery = queryBuilder.prepare(); 上述符合查询相当于如下SQL： SELECT * FROM account WHERE (name = &#39;foo&#39; AND password = &#39;_secret&#39;) 示例2：复杂查询 123456789Where&lt;Account, Object&gt; where = queryBuilder.where();where.or( where.and( where.eq(Account.NAME_FIELD_NAME, "foo"), where.eq(Account.PASSWORD_FIELD_NAME, "_secret")), where.and( where.eq(Account.NAME_FIELD_NAME, "bar"), where.eq(Account.PASSWORD_FIELD_NAME, "qwerty")) ); 相当于如下SQL： SELECT * FROM account WHERE ((name = &#39;foo&#39; AND password = &#39;_secret&#39;) OR (name = &#39;bar&#39; AND password = &#39;qwerty&#39;)) ORMLite进行联合查询ORMLite支持Join联合查询，示例如下 12345QueryBuilder&lt;User, Object&gt; userQb = userDao.queryBuilder();userQb.where().ge("id", 10);QueryBuilder&lt;Account, Object&gt; accountQb = accountDao.queryBuilder();// join with the order queryList&lt;Account&gt; results = accountQb.join(userQb).query(); 注意事项： ORMLite仅支持内连接与左连接，不支持右连接与全连接 ORMLite在Spring中的配置ORMLite支持Spring容器中使用 下面的示例片段是Spring对ORMLite的url，数据源，connectionsource，Dao工厂的配置片段：（完整的配置文件见附录代码） 123456789101112131415161718192021222324&lt;!-- database url --&gt;&lt;bean id="databaseUrl" class="java.lang.String"&gt; &lt;constructor-arg index="0" value="jdbc:sqlite:Q:/sqlite3/abc.db" /&gt;&lt;/bean&gt;&lt;!--使用dbcp数据源 --&gt;&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="org.sqlite.JDBC" /&gt; &lt;property name="url" ref="databaseUrl" /&gt;&lt;/bean&gt;&lt;!-- ConnectionSource --&gt;&lt;bean id="connectionSource" class="com.j256.ormlite.jdbc.DataSourceConnectionSource" init-method="initialize"&gt; &lt;property name="databaseUrl" ref="databaseUrl" /&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;&lt;!-- accountDao --&gt;&lt;bean id="accountDao" class="com.j256.ormlite.spring.DaoFactory" factory-method="createDao"&gt; &lt;constructor-arg index="0" ref="connectionSource" /&gt; &lt;constructor-arg index="1" value="com.fiberhome.ormlite.spring.Account" /&gt;&lt;/bean&gt; 注意事项： 所有类型ConnectionSource必须配置初始化方法initialize，否则抛异常 前文已提到DataSourceConnectionSource无法关闭数据源，因而数据源需要配置destroy-method=”close” 项来关闭数据源 ORMLite事务支持与批量操作Sqlite支持事务。使用ORMLite时可用通过ORMLite内置的事务管理器完成事务操作。 事务操作示例代码如下： 123456789101112TransactionManager.callInTransaction(connectionSource, new Callable&lt;Void&gt;() &#123; public Void call() throws Exception &#123; // insert our order accountDao.create(account); // now add the account to the order order.setAccount(account); // update our order object orderDao.update(order); // you could pass back an object here return null; &#125;&#125;); ORMLite支持批量操作。对于大量的插入、修改等操作来说，调用批量操作接口可用提高数据库的性能。示例代码如下： 1234567accountDao.callBatchTasks(new Callable&lt;Void&gt;() &#123; public Void call() throws Exception &#123; for (Account account : accountsToInsert) &#123; accountDao.create(account); &#125; &#125;&#125;); 注意事项： 从源码层面看，事务与批量操作的实现十分相似，都是首先setAutoCommit(false)，然后执行一系列操作，最后在连接上执行 commit()方法，不同的是如果发生异常，事务会回滚而批量操作不会回滚。 事物内部通过调用connectionSource的getReadWriteConnection() 方法获取一个数据库连接，然后在该数据库连接上进行事务操作。connectionSource内部通过一个ThreadLocal变量保证同一个线程获取到的数据库连接是同一个连接，我们也可以手动的获取连接配置提交事务，但最后要记得释放连接到连接池中。]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>ORM</tag>
        <tag>ORMLite</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存模型知识点小结---《深入理解Java内存模型》（程晓明）读书总结]]></title>
    <url>%2F2017%2FJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.html</url>
    <content type="text"><![CDATA[Java内存模型介绍内存模型的作用范围在Java中，所有实例域、静态域和数组元素存放在堆内存中，线程之间共享，下文称之为”共享变量”。局部变量、方法参数、异常处理器等不会在线程之间共享，不存在内存可见性问题，也不受内存模型的影响。 重排序与可见性：现代编译器在编译源码时会做一些优化处理，对代码指令进行重排序；现代流水线结构的处理器为了提高并行度，在执行时也可能对指令做一些顺序上的调整。重排序包括编译器重排序、指令级并行重排序和内存系统重排序等。一般来说，编译器和处理器在做重排序的时候都会做一些保证，保证程序的执行结果与重排序之前指令的执行结果相同。即as-if-serial,不管怎样重排序，都不能改变程序的执行结果。 CPU在执行指令时一般都会使用缓存技术来提高效率，如果不同线程使用不同的缓存空间则会造成一个线程对一个共享变量的更新不能及时反映给其他线程，也就是多线程对共享变量更新的可见性问题，这个问题是非常复杂的。 Java内存模型的抽象：对于上述问题，Java内存模型（JMM）为程序员提供了一个抽象层面的描述，我们不用去关心编译器、处理器对指令做了怎样的重排序，也不用关心复杂的系统缓存机制，只要遵循JMM的规则，JMM就能为我们提供代码顺序性、共享变量可见性的保证，从而得到预期的执行结果。 JMM决定了一个线程对共享变量的写入何时对另一个线程可见。从抽象来讲，线程共享变量存放在主内存（main memory），每个线程持有一个本地内存（local memory），本地内存中存储了该线程读写共享变量的副本（本地内存是JMM的一个抽象概念，并不是真实存在的）。如下图： 如果A、B两个线程要通信要经过以下两步：首先线程A将本地内存中更新过的共享变量刷新到主内存中，然后线程B到主内存中读取A之前更新过的变量。 JMM通过控制主内存与每个线程的本地内存之间的交互来为Java程序员提供可见性保证。 重排序：现代编译器和处理器会对指令执行的顺序进行重排序，以此提高程序的性能。这些重排序可能会导致多线程程序出现内存可见性问题。为了不改变程序的执行结果，对于编译器，JMM会禁止特定类型的编译器重排序；对于处理器重排序，JMM要求在Java编译生产指令序列时，插入特定类型的内存屏障（memory barriers）来禁止特定类型的重排序。 JMM把内存屏障分为以下四类： 屏障类型 指令示例 说明 LoadLoad Barriers Load1; LoadLoad; Load2 确保Load1数据的装载之前于在Load2及其所有后续装载指令 StoreStore Barriers Store1; StoreStore; Store2 确保Store1刷新数据到内存之前与Store2及其后续存储指令 LoadStore Barriers Load1; LoadStore; Store2 确保Load1数据装载之前于Store2及其后续存储指令 StoreLoad Barriers Store1; StoreLoad; Load2 确保Store1刷新数据到内存之前于Load2及其后续装载指令 StoreLoad Barriers会使该屏障之前的所有内存访问指令完成后才执行屏障后的指令。 StoreLoad Barriers是一个全能型屏障，同时具有其他三个屏障的效果。 Happens-before:从JDK1.5开始，Java使用新的JSR-133内存模型（以下所有都是针对该内存模型讲的），使用happens-before的概念来阐述操作之间的内存可见性。 如果一个操作要对另一个操作可见，那这两个操作之间必须存在happens-before关系。这两个操作可以在一个线程内，也可以在不同线程之间。ps.（两个操作存在happens-before关系并不意味着前一个操作必须在后一个操作之前执行，仅仅要求前一个操作对后一个操作可见。） 常见的与程序员相关的happens-before规则如下： 程序顺序规则：一个线程中的每个操作happens-before于其后的任意操作； 监视器锁规则：对一个监视器的解锁happens-before于随后对这个监视器的加锁； volatile规则：对一个volatile域的写happens-before于任意后续对该域的读操作（该规则多个线程之间也成立）； 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C 数据依赖性：如果两个操作访问同一个变量，且这两个操作其中一个为写操作时，这两个操作就存在数据依赖性。如下示例： 写后读: a=1; b=a; 写后写: a=1; a=2; 读后写: a=b; b=a; 上述三类情况存在数据依赖性，此时不允许重排序，否则程序的结果可能会改变。 as-if-serial语义： as-if-serial语义的意思是：在单线程内，不管怎么重排序，程序的执行结果不变，在程序员看来，就像顺序执行的一样。 示例： 123a = 1; //Ab = 2; //Bc = a + b; //C 前两条语句就可以进行重排序，而第三条语句与前两条存在依赖关系，不能重排序。 上述A happens-before B，B happens-before C， 但并不保证A在B之前执行，只需要保证操作A对B可见（这里A操作不需要对B可见，因此可以重排） 重排序对多线程的影响： 示例： 123456789101112131415class Demo &#123; boolean flag = false; int a = 0; public void fun1() &#123; a = 1; //A flag = true; //B &#125; public void fun2() &#123; if (flag) &#123; //C a = a + a; //D &#125; &#125;&#125; 假设上述类中fun1()和fun2()在不同线程中执行，操作A、B没有依赖关系，可能被重排序；操作C、D虽然存在控制依赖关系，现代编译器和处理器为了提高并行度，可能采取激进的方法（即先求出if语句块中的值存于临时变量中，如果if条件为真则使用该值，否则丢弃）对其进行重排序，这都可能改变程序的执行结果。 顺序一致性内存模型：计算机科学家们提出了一个理想化的理论参考模型–顺序一致性模型，它为程序员提供了极强的内存可见性，具有如下两大特性： 一个线程中的所有操作必须按照程序顺序来执行； 所有线程（无论同步与否）都只能看到一个单一的操作执行顺序。每个操作都必须是原子的且立刻对所有线程可见。 示例： 假设有A和B两个线程并发执行，A线程中有三个操作，顺序是A1-&gt;A2-&gt;A3，线程B中也有三个操作，顺序是B1-&gt;B2-&gt;B3。 先假设这两个线程使用监视器同步，A线程先获得监视器，执行完毕释放监视器后线程B开始执行。那么他们在顺序一致性模型中执行效果如下： 现在我们再假设这两个线程未进行同步，其在顺序一致性模型中执行效果如下： 可以看到，未同步的程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只看到一个一致的整体执行顺序。如上图，线程A和B看到的执行顺序都是B1-&gt;A1-&gt;A2-&gt;B2-A3-&gt;B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任何线程可见。 但是JMM中没有这个保证。比如当前线程写数据到本地内存中，在还没有刷新到主内存之前，这个写操作只对当前线程可见，从其他线程角度观察，可以认为这个写操作根本还没有被当前线程执行过。这种情况下，当前线程和其他线程看到的操作执行顺序将不一致。 同步程序的一致性效果： 示例： 1234567891011121314class SynchronizedDemo &#123; int a = 0; boolean flag = false; public synchronized void write() &#123; a = 1; flag = true; &#125; public synchronized void read() &#123; if(flag) &#123; int i = a; &#125; &#125;&#125; 上述代码使用同步方法，线程A先执行write()方法，释放锁后线程B获取锁并执行read()方法，执行流程如下： 在顺序一致性模型中，所有操作按顺序执行。在JMM中，临界区内的代码可以重排序（JMM不允许临界区内的代码”逸出”到临界区之外），JMM会在进入和退出临界区的关键点上做一些限定，使得现场在这两个关键点处具有和顺序一致性模型具有相同的内存视图。虽然现场A在临界区内做了重排序，但由于监视器的互斥性，这里线程B根本无法”观察”到线程A在临界区内的重排序，这样既提高了效率又不改变程序的执行结果。 对于未同步的多线程程序，JMM只提供最小安全性：线程执行读操作取得的值，要么是之前线程写入的，要么是默认值（0，null,false）,JMM保证线程读取的数据不是无中生有冒出来的。为了实现最小安全，JVM在堆上分配对象时首先会清空内存空间，然后才分配对象（因此对象分配时，域的默认初始化已经完成）。 此外，JMM的最小安全不保证对64位的long和double型变量的读写具有原子性，而顺序一致性模型保证对所有内存读写操作具有原子性。 Volatile特性volatile变量的单次读写，相当于使用了一个锁对这些单个读/写做了同步。 原子性：对volatile变量的单次读写操作具有原子性（ps.这里貌似存在争议，暂且这么写，保留意见）； 可见性：锁的happens-before规则保证释放锁和获取锁的两个线程之间的可见性，这意味着对一个volatile变量的读操作总能看到之前任意线程对这个volatile变量最后的写入，即对volatile变量的写操作对其他线程立即可见。 当写一个volatile变量时，JMM会把线程对应的本地内存中的共享变量刷新到主内存； 当读一个volatile变量时，JMM会把改下昵称对应的本地内存置为无效，接下来从主内存中读取共享变量的值。 从内存语义的角度来说，volatile的写-读于锁的释放-获取具有相同的内存效果。因此如果线程A对volatile变量的写操作在线程B对volatile变量的读操作之前，则其存在happens-before关系。 示例： 123456789101112131415class VolatileDemo &#123; volatile boolean flag = false; int a=0; public void fun1() &#123; a=1; //A flag = true; //B &#125; public void fun2() &#123; if (flag) &#123; //C a=a+a; //D &#125; &#125;&#125; 上述操作A happens-before 操作B，操作C happens-before 操作D，如果线程1调用fun1()方法之后线程2调用fun2()方法，则操作B happens-before 操作C，根据happens-before的传递性，则有A happens-before D，因此可以保证操作D可以正确读取到操作A的赋值。 Volatile的内存语义是JMM通过在volatile读写操作前后插入内存屏障实现的。 锁的特性锁的释放与获取遵循happens-before规则，释放锁线程临界区的操作结果对获取锁的线程可见。 当线程释放锁时，JMM会把线程对应的本地内存中的共享变量刷新到主内存； 当线程获取锁时，JMM会把改下昵称对应的本地内存置为无效，接下来从主内存中读取共享变量的值。 ReentrantLock是java.util.concurrent.locks包下的一个锁的实现，依赖对volatile变量的读写和compareAndSet(CAS)操作实现锁机制。其中CAS操作使用不同的CPU指令实现单次操作的原子性，具有volatile读写操作相同的内存语义。 类图如下： ReentrantLock根据对抢占锁的线程的处理方式不同，分为公平锁和非公平锁，首先看公平锁，使用公平锁加锁时，加锁方法lock()的方法调用主要有以下四步： 12341\. ReentrantLock : lock()2\. FairSync : lock()3\. AbstractQueuedSynchronizer : acquire(int arg)4\. ReentrantLock : tryAcquire(int acquires) 在第四步才开始真正加锁，该方法的源码如下： 12345678910111213141516171819protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState();();//获取锁的开始，state是volatile类型变量 if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 从上面方法可以看出，加锁方法首先读取volatile变量state。 使用公平锁的unlock()方法调用轨迹如下： 1231\. ReentrantLock : unlock()2\. AbstractQueuedSynchronizer : release(int arg)3\. Sync : tryRelease(int releases) 在第三步调用时才真正开始释放锁，该方法源码如下： 123456789101112protected final boolean tryRelease (int releases)&#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false ; if (c == 0)&#123; free = true ; setExclusiveOwnerThread( null ); &#125; setState(c);//释放锁后，写volatile变量state return free;&#125; 从上面代码可以看出，在释放锁的最后写volatile变量state。 公平锁在释放锁的最后写volatile变量state，在获取锁的时候首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之后该变量对获取锁的线程可见。 Java中的CAS操作同时具有volatile读和volatile写的内存语义，因此Java线程之间通信现在有了以下四种方式： 1、A线程写volatile变量，随后B线程读这个volatile变量。 2、A线程写volatile变量，随后B线程用CAS更新这个volatile变量。 3、A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。 4、A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。A线程写 Java的CAS会使用现代处理器上提供的高效机器级别原子指令，这些原子指令以原子方式对内存执行读-改-写操作，同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式： 首先，声明共享变量为volatile； 然后，使用CAS的原子条件更新来实现线程之间的同步； 同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。 Final 的特性与前面介绍的锁和volatile相比较，对final域的读和写更像是普通的变量访问。对于final域，编译器和处理器要遵守两个（分别对应读写）重排序规则： 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。 写final域的重排序规则写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面： 1、JMM禁止编译器把final域的写重排序到构造函数之外。 2、编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外 。 写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障 对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束： 在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 读final域的重排序规则在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。 读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。]]></content>
      <tags>
        <tag>java</tag>
        <tag>JMM</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML解析之JAXB]]></title>
    <url>%2F2017%2FXML%E8%A7%A3%E6%9E%90%E4%B9%8BJAXB.html</url>
    <content type="text"><![CDATA[XML 是一种网络通信的数据交换的重要公共语言，是跨平台跨语言通信的一种重要手段，也是复杂配置文件的常用格式。在 Java 中操作 XML 是相当方便的，常用的读取解析xml的方式有DOM（Document Object Mode）模型和SAX（Simple API for XML）模型等，这些方式网络上的资料非常多，这里不再赘述。 无论是DOM模型还是SAX模型，都需要用户根据XML文件的内容格式手动配置解析各个元素属性等，使用起来还是不够方便。如果有一种方式能将xml结构与javabean对象相互映射，那将大大简化xml文件解析过程，使用起来非常方便。 本文介绍Jaxb对xml文件的解析。 Jaxb（Java Architecture for XML Binding) 是一个业界的标准，它使用注解配置，提供XML文件与Java对象之间的自动映射。JDK6以上版本已经集成JAXB功能，无需第三方依赖即可直接使用。 从JavaBean对象到XML的映射首先创建一个JavaBean类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.List;import javax.xml.bind.annotation.XmlAttribute;import javax.xml.bind.annotation.XmlList;import javax.xml.bind.annotation.XmlRootElement;import javax.xml.bind.annotation.XmlType;@XmlRootElement(name = "doc")public class DocType &#123; private String name; private int id; private String attr; private List&lt;String&gt; lst; public List&lt;String&gt; getLst() &#123; return lst; &#125; public DocType setLst(List&lt;String&gt; lst) &#123; this.lst = lst; return this; &#125; @XmlAttribute public String getAttr() &#123; return attr; &#125; public void setAttr(String attr) &#123; this.attr = attr; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; @Override public String toString() &#123; return "DocType [name=" + name + ", id=" + id + ", attr=" + attr + ", lst=" + lst + "]"; &#125;&#125; 测试类（测试从javaBean映射到XML）： 123456789101112131415161718192021222324import java.util.Arrays;import javax.xml.bind.JAXBContext;import javax.xml.bind.JAXBException;import javax.xml.bind.Marshaller;public class JavaBean2XMLTest&#123; public static void main(String[] args) throws JAXBException &#123; //从JavaBean对象到XML文件 DocType doc = new DocType(); doc.setName("Lee"); doc.setId(11); doc.setAttr("attr"); doc.setLst(Arrays.asList("lst1","lst2")); // JAXBContext context = JAXBContext.newInstance(DocType.class); Marshaller marshaller = context.createMarshaller(); marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); marshaller.setProperty(Marshaller.JAXB_ENCODING, "utf-8"); marshaller.marshal(doc, System.out); &#125;&#125; 输出： 1234567&lt;?xml version="1.0" encoding="utf-8" standalone="yes"?&gt;&lt;doc attr="attr"&gt; &lt;id&gt;11&lt;/id&gt; &lt;lst&gt;lst1&lt;/lst&gt; &lt;lst&gt;lst2&lt;/lst&gt; &lt;name&gt;Lee&lt;/name&gt;&lt;/doc&gt; 从XML到JavaBean对象的映射测试类（测试从XML到JavaBean对象）：将上述XML内容保持在文件 D:/test.xml中 12345678910111213141516import java.io.FileInputStream;import java.io.InputStream;import javax.xml.bind.JAXBContext;import javax.xml.bind.Unmarshaller;public class XML2JavaBeanTest &#123; public static void main(String[] args) throws Exception &#123; InputStream is=new FileInputStream("D:/test.xml"); String packageName = DocType.class.getPackage().getName(); JAXBContext jc = JAXBContext.newInstance(packageName); Unmarshaller u = jc.createUnmarshaller(); DocType doc = (DocType)u.unmarshal(is); System.out.println(doc); &#125;&#125; 这个测试代码会抛出异常javax.xml.bind.JAXBException。原因是从XML到JavaBean对象需要创建JavaBean对象，JAXB不会自动去new一个JavaBean对象，而是在Context中查找已注册ObjectFactory的类，然后使用该类创建对象。因而我们在 DocType.java相同的包下创建一个ObjectFactory类，并加上@XmlRegistry注解，代码如下： 123456789import javax.xml.bind.annotation.XmlRegistry;@XmlRegistrypublic class ObjectFactory &#123; public DocType createDocType()&#123; return new DocType(); &#125;&#125; 然后再运行上述测试类，输出如下： DocType [name=Lee, id=11, attr=attr, lst=[lst1, lst2]] 这正是DocType类的toString内容，说明了从XML到JavaBean对象映射成功。 Jaxb对JavaBean与XML映射时，默认将所有的public属性和方法都映射为XML元素，即AccessType为PUBLIC_MEMBER。对于上述DocType类，我们也可以省略掉所有的public的get和set方法，在类上加注解@XmlAccessorType(XmlAccessType.FIELD)同样可以实现从XML到JavaBean内容的映射，如下： 1234567891011121314@XmlRootElement(name = "doc")@XmlAccessorType(XmlAccessType.FIELD)public class DocType &#123; private String name; private int id; @XmlAttribute private String attr; private List&lt;String&gt; lst;@Override public String toString() &#123; return "DocType [name=" + name + ", id=" + id + ", attr=" + attr + ", lst=" + lst + "]"; &#125;&#125; 将DocType改为上面代码后运行XML2JavaBeanTest 测试类，输出相同的内容。 如果希望某个JavaBean属性映射为XML元素的属性而非XML元素值，可以在对应的属性上加注解@XmlAttribute，如上述代码中的 12@XmlAttributeprivate String attr; 更加复杂的映射对于更加复杂的映射，下面给出一个例子，涵盖了多层次的引用、枚举、自定义父元素标签、自定义映射适配器、XmlTransient注解映射忽略等内容，不再详细讲解，根据代码注释就可以看得懂。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.List;import javax.xml.bind.annotation.XmlElementWrapper;import javax.xml.bind.annotation.XmlRootElement;import javax.xml.bind.annotation.XmlTransient;@XmlRootElementpublic class RefDocType &#123; private String name; //引用类型 private SubType subType; //多层次引用类型 private SubValue subTypeValue; //列表类型 private List&lt;String&gt; lst; //不序列化到xml文件中,对应public方法上加注解@XmlTransient private String transName; //枚举类型 private SubEnumType subElem=SubEnumType.E1; public SubEnumType getSubElem() &#123; return subElem; &#125; public void setSubElem(SubEnumType subElem) &#123; this.subElem = subElem; &#125; public SubValue getSubTypeValue() &#123; return subTypeValue; &#125; public void setSubTypeValue(SubValue subTypeValue) &#123; this.subTypeValue = subTypeValue; &#125; //这个注解表示不映射该属性到xml中 @XmlTransient public String getTransName() &#123; return transName; &#125; public void setTransName(String transName) &#123; this.transName = transName; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public SubType getSubType() &#123; return subType; &#125; public void setSubType(SubType subType) &#123; this.subType = subType; &#125; //这个注解标明在该元素外增加一个父元素“myWapper” @XmlElementWrapper(name="myWapper") public List&lt;String&gt; getLst() &#123; return lst; &#125; public void setLst(List&lt;String&gt; lst) &#123; this.lst = lst; &#125;&#125; 12345678910111213141516171819202122232425262728293031import javax.xml.bind.annotation.XmlEnum;import javax.xml.bind.annotation.XmlEnumValue;@XmlEnumpublic enum SubEnumType &#123; @XmlEnumValue("e1") E1("e1"), @XmlEnumValue("e2") E2("e2"); // ...(more enum constant definitions) private final String value; SubEnumType(String v) &#123; value = v; &#125; public String value() &#123; return value; &#125; public static SubEnumType fromValue(String v) &#123; for (SubEnumType c: SubEnumType.values()) &#123; if (c.value.equals(v)) &#123; return c; &#125; &#125; throw new IllegalArgumentException(v.toString()); &#125;&#125; 12345public class SubSubValue &#123; public String v="subsubValue";&#125; 12345678910111213public class SubType &#123; private String value; public String getValue() &#123; return value; &#125; public SubType setValue(String value) &#123; this.value = value; return this; &#125;&#125; 123456789101112131415161718192021import javax.xml.bind.annotation.XmlValue;import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;public class SubValue &#123; private SubSubValue value; //该JavaBean属性本身是一个引用类型的对象，默认会映射为一个XML元素 //@XmlValue标明将该JavaBean属性直接映射为一个XML元素的值 //Jaxb不知道该如何将其直接映射为元素值，因此使用一个自定义适配器 MyAdapter @XmlValue @XmlJavaTypeAdapter(MyAdapter.class) public SubSubValue getValue() &#123; return value; &#125; public SubValue setValue(SubSubValue value) &#123; this.value = value; return this; &#125;&#125; 1234567891011121314import javax.xml.bind.annotation.adapters.XmlAdapter;public class MyAdapter extends XmlAdapter&lt;String, SubSubValue&gt; &#123; @Override public SubSubValue unmarshal(String v) throws Exception &#123; return new SubSubValue(); &#125; @Override public String marshal(SubSubValue v) throws Exception &#123; return v.v; &#125;&#125; 测试类： 12345678910111213141516171819public class ComplexReflectionTest &#123; public static void main(String[] args) throws JAXBException &#123; RefDocType ref=new RefDocType(); ref.setName("ref"); ref.setSubType(new SubType().setValue("subValue")); ref.setSubTypeValue(new SubValue().setValue(new SubSubValue())); ref.setTransName("transName"); List&lt;String&gt; lst =new ArrayList&lt;String&gt;(Arrays.asList("lst1","lst2")); ref.setLst(lst); // JAXBContext context = JAXBContext.newInstance(ref.getClass()); Marshaller marshaller = context.createMarshaller(); marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true); marshaller.setProperty(Marshaller.JAXB_ENCODING, "utf-8"); marshaller.marshal(ref, System.out); // &#125;&#125; 输出结果： 12345678910111213&lt;?xml version="1.0" encoding="utf-8" standalone="yes"?&gt;&lt;refDocType&gt; &lt;myWapper&gt; &lt;lst&gt;lst1&lt;/lst&gt; &lt;lst&gt;lst2&lt;/lst&gt; &lt;/myWapper&gt; &lt;name&gt;ref&lt;/name&gt; &lt;subElem&gt;e1&lt;/subElem&gt; &lt;subType&gt; &lt;value&gt;subValue&lt;/value&gt; &lt;/subType&gt; &lt;subTypeValue&gt;subsubValue&lt;/subTypeValue&gt;&lt;/refDocType&gt;]]></content>
      <tags>
        <tag>XML</tag>
        <tag>JAXB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring常用配置示例]]></title>
    <url>%2F2017%2FSpring%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E%20.html</url>
    <content type="text"><![CDATA[Spring 是一款Java平台的开源框架，是为解决企业级应用程序开发的复杂性而创建的，通过良好的分层架构让开发人员能够专注于业务逻辑的开发。 Spring框架是一个分层架构，由不同的模块组成，构成spring的每个组件或模块都可以单独使用或者多个模块配合使用，以实现不同的功能需求。Spring框架的模块结构如下图所示： SpringCore是Spring框架的核心模块，提供spring框架的基本功能，使用工厂模式BeanFactory通过控制反转（IoC）、依赖注入（DI）等实现对beans的管理功能，将对象间的耦合关系通过配置文件进行管理，实现了“低耦合”的程序设计原则。 SpringContext通过配置文件的方式向spring提供上下文服务，如JNDI、国际化、校验等 SpringDAO是spring框架对数据访问的抽象，封装了对JDBC的操作，统一了异常结构用于管理不同数据库厂商产品抛出的错误信息，简化了对异常信息的处理。 SpringORM负责spring与ORM框架的集成，如Hibernate、MyBatis等。 SpringWeb是spring的Web模块，提供WebApplication的上下文信息，实现如文件上传、数据绑定、与其他框架（如Struts）的集成等。 SpringWebMVC是一个Web的MVC框架，提供了对Controller、Model、Service等组件的管理，视图层通过不同的视图解析器支持多种视图技术，如JSP、Velocity、FreeMarker等 SpringAOP是Spring对面向切面编程的支持，支持JDK和CGLib两种字节码操作方式，可以实现对Spring管理的任意对象的AOP支持。 Spring框架的配置文件是基于xml的，Spring强大的功能依赖于类型繁多的配置项，这些配置项纷繁复杂难以记忆，下面将常用的配置项示例记录下来，以备后续查看使用。 Spring配置—-命名空间：123456789101112131415&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" &lt;!-- 默认bean命名空间 --&gt;xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" &lt;!-- 固定格式 --&gt;xmlns:aop="http://www.springframework.org/schema/aop"&lt;!-- AOP命名空间的scheme约束 --&gt;xmlns:context="http://www.springframework.org/schema/context"&lt;!-- context命名空间的scheme约束 --&gt;xsi:schemaLocation=" &lt;!-- 上面各个scheme的location信息 --&gt; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd "&gt;&lt;/beans&gt; Spring Beans主要配置：12345678910111213141516171819202122232425262728&lt;bean class="bean的完全限定名" name/id="bean在容器内的唯一名称" scope＝"bean的生命周期" lazy-init="是否为延迟加载" init-method＝"bean的setter被调用之后调用该方法进行初始化" destroy-method＝"容器在销毁该Bean后的调用的方法" abstract="是否为抽象Bean，spring对于抽象bean不产生实例，主要用于继承" parent="父Bean的名称，会继承父Bean的属性，与Java的Class无任何关系" factory-method="工厂方法的名字" factory-bean="工厂Bean的名字" depends-on ＝"依赖Bean的名字，保证初始化顺序。” &gt; &lt;!-- Constructor-arg给属性赋值写法一 --&gt; &lt;constructor-arg type="int" value="10"/&gt; &lt;!-- Constructor-arg给属性赋值写法二 --&gt; &lt;constructor-arg name="age" value="10"/&gt; &lt;!-- Constructor-arg给属性赋值写法三 --&gt; &lt;constructor-arg index="0" value="10"/&gt; &lt;!-- Properties给属性赋值写法一 --&gt; &lt;property name="bean1"&gt; &lt;ref bean="另外一个bean的id"/&gt; &lt;/property&gt; &lt;!-- Properties给属性赋值写法二 --&gt; &lt;property name="bean1" ref="另外一个bean的id"/&gt; &lt;!-- Properties给属性赋值写法三 --&gt; &lt;property name="age" value="10"/&gt;&lt;/bean&gt; Spring 配置—-context：自动扫描包（默认设置） 1&lt;context:component-scan base-package=&quot;com.xxx.test&quot; /&gt; 自动扫描包（含过滤器） 1234567891011&lt;context:component-scan base-package=&quot;cn.xxx.test&quot; &gt; &lt;!-- 根据注解（包含） --&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Component&quot;/&gt; &lt;!-- 根据aspectJ语法，一般用于AOP --&gt; &lt;context:include-filter type=&quot;aspectj&quot; expression=&quot;&quot;/&gt; &lt;!-- 根据正则表达式（排除） --&gt; &lt;context:exclude-filter type=&quot;regex&quot; expression=&quot;&quot;/&gt; &lt;/context:component-scan&gt;&lt;!-- 注解支持 --&gt;&lt;context:annotation-config/&gt; 激活Spring对class的注解检测，该配置会向Spring 容器注册一些BeanPostProcessor用于处理注解， 如：AutowiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor、PersistenceAnnotationBeanPostProcessor 和 RequiredAnnotationBeanPostProcessor 比如要使用@AutoWired注解，需要向Spring注册如下的bean ：1&lt;bean class=&quot;org.springframework.beans.factory.annotation. AutowiredAnnotationBeanPostProcessor &quot;/&gt; 如果要使用@Required的注解，就必须注册如下bean：1&lt;bean class=&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;/&gt; 而使用&lt;context:annotation-config/&gt;相当于简化了操作。 另外如果配置了context:component-scan 则同样具备了注解检测的功能，此种情况下可以移除context:annotation-config Spring 配置—-AOP：一些基本概念： 方面（Aspect）：即切面，一个关注点的模块化，这个关注点实现可能另外横切多个对象。 连接点（Joinpoint）：程序执行过程中明确的点，如方法的调用或特定的异常被抛出。 通知（Advice）：在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”、“after”和“throws”通知。 切入点（Pointcut）：指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点，例如，使用正则表达式。 引入（Introduction）：添加方法或字段到被通知的类。Spring允许引入新的接口到任何被通知的对象。 目标（Target）：包含连接点的对象，也被称作被通知或被代理对象。 代理（Proxy）：AOP框架创建的对象，包含通知。在Spring中，AOP代理可以是JDK动态代理或CGLIB代理。 编织（Weaving）：组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯JavaAOP框架一样，在运行时完成织入。 AOP的xml配置1234567891011&lt;bean id=&quot;myadvice&quot; class=&quot;cn.test.MyAdvice&quot; /&gt;&lt;bean id=&quot;targetclass&quot; class=&quot;cn.test.aop.TargetClass&quot; /&gt;&lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* cn.test.aop.*.*(..))&quot; id=&quot;pt&quot; /&gt; &lt;aop:aspect ref=&quot;myadvice&quot;&gt; &lt;aop:before method=&quot;beforeAdvice&quot; pointcut-ref=&quot;pt&quot; /&gt; &lt;aop:after method=&quot;afterAdvice&quot; pointcut-ref=&quot;pt&quot; /&gt; &lt;aop:around method=&quot;aroundAdvice&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; AOP的注解配置使用注解的方式实现AOP（示例）：1234567891011121314151617181920212223242526272829303132@Component@Aspectpublic class MyAdvice2 &#123; //拦截cn.test.spring.aop包下所有类的所有方法 final String exp="execution(* cn.test.spring.aop.*.*(..))"; @Before(exp) public void beforeAdvice()&#123; System.out.println("before advice2"); &#125; @After(exp) public void afterAdvice()&#123; System.out.println("after advice2"); &#125; @AfterReturning(exp) public void afterRetAdvice()&#123; System.out.println("after return advice2"); &#125; @Around(exp) public void aronudAdvice(ProceedingJoinPoint jp)&#123; System.out.println("start arround advice2"); try &#123; jp.proceed(); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; System.out.println("after arround advice2"); &#125;&#125; Spring 配置—-MVC：对web.xml文件的配置项：123456789101112131415161718192021222324&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;!-- Spring Web配置 --&gt;&lt;listener&gt; &lt;listenerclass&gt;org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt; &lt;!-- 指定Spring Bean的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:config/applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 对spring配置文件的相关配置项：1234567891011121314151617181920212223242526&lt;mvc:annotation-driven /&gt;&lt;context:component-scan base-package=&quot;cn.spring.test&quot; /&gt;&lt;!-- 如果当前请求为“/”时，则转发到“index”视图 --&gt;&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;forward:index&quot; /&gt;&lt;!-- 静态资源映射 --&gt;&lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/WEB-INF/js/&quot; /&gt;&lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/WEB-INF/css/&quot; /&gt;&lt;mvc:resources mapping=&quot;/fonts/**&quot; location=&quot;/WEB-INF/fonts/&quot; /&gt;&lt;mvc:resources mapping=&quot;images/**&quot; location=&quot;/WEB-INF/images/&quot; /&gt;&lt;!-- 当上面要访问的静态资源不存在与上面的配置中时，则根据此配置来访问 --&gt;&lt;mvc:default-servlet-handler /&gt;&lt;!-- 支持上传文件 --&gt;&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;maxUploadSize&quot;&gt; &lt;value&gt;xxx&lt;/value&gt;&lt;/property&gt; &lt;property name=&quot;defaultEncoding&quot;&gt; &lt;value&gt;UTF-8&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- jsp视图解析器 --&gt;&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; &gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsps/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;&lt;/bean&gt; 文件上传示例代码：1234567@RequestMapping("/upload")@ResponseBodypublic String fileUpload(@RequestParam("formFile") MultipartFile formFile) throws IOException &#123; String fileContent=new String(formFile.getBytes()); //write to local file return "code:0";&#125;]]></content>
      <tags>
        <tag>Spring</tag>
        <tag>spring配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系型数据库知识小结]]></title>
    <url>%2F2017%2F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E5%B0%8F%E7%BB%93.html</url>
    <content type="text"><![CDATA[基础术语DML（data manipulation language） 如SELECT、UPDATE、INSERT、DELETE，主要用来对数据库里的数据进行操作的语言 DDL（data definition language） 主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，大多在建立表时使用。 DCL（Data Control Language） 数据库控制功能。是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。默认情况下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员才有权力执行DCL 数据库三范式关系型数据库设计表时为了减小冗余，增强数据的有效性和存储效率，需要遵循一定的规范，这些规范按照严格程度来区分可以分为第一范式（1NF），第二范式（2NF），第三范式（3NF），BC范式（BCNF），第四范式（4NF），第五范式（5NF）等。 数据库范式是数据库设计中必不可少的理论依据，不理解数据库范式就无法设计出搞笑优雅的数据库，甚至依赖混乱，操作经常出错。实际应用中常用的范式有第一范式（1NF），第二范式（2NF）和第三范式（3NF），后面三个范式则用的比较少，这是因为适当的冗余可以增加数据库的查询效率。 第一范式（1NF）：属性不可分第一范式要求数据库表中所有字段都是不可分的原子值。不满足第一范式的数据库，不是关系数据库！ 第二范式（2NF）：非主属性完全依赖于码第二范式是在第一范式的基础上更进一步，要求数据库要有主键，其他非主属性完全依赖于主键，而不能只依赖主键中的一部分。即联合主键的情况，如果某一个非主属性只依赖于联合主键中的一个或者部分属性，则不符合第二范式。第二范式隐式要求数据库一张表只保存一种数据，尽量不要把多种数据保存到一张表中。 第三范式（3NF）：非主属性之间不存在传递依赖第三范式是在第二范式的基础上更进一步，要求属性不能依赖于表中的非主属性。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。 事务：事务（Transaction）是并发控制的基本单位。所谓事务，即一系列操作的集合，这些操作要么都不执行，要么全部执行，不允许执行其中一部分，即把一系列操作作为一个整体进行控制。比如银行转账，简化下来至少需要两步操作: 要从A账户扣除100元 给B账户增加100元 这两步操作必须作为一个整体进行控制，假如从A账户扣款成功，给B账户增加金额失败，则事务必须回滚（roolback）,即把A账户的扣款返回给A账户。 事务具有四个基本特征（ACID）：Atomic（原子性）：事务中包含的操作被看做一个逻辑单元，这个逻辑单元中的操作要么全部成功，要么全部失败。 Consistency（一致性）：只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。 Isolation（隔离性）：事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。这表明事务必须是独立的，不应该以任何方式以来于或影响其他事务。 Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。事务完成之后，它对于系统的影响是永久的，该修改即使出现系统故障也将一直保留，真实的修改了数据库。 如果多个事务同时影响同一条或者同一些数据，将会导致数据混乱或者事务执行失败，因此需要对事务的并发进行控制。隔离级别就是对对事务并发控制的等级。SQL-92标准中定义了四个隔离级别，串行化（SERIALIZABLE）、可重复读（REPEATABLE READ）、读已提交（READ COMMITED）、读未提交（READ UNCOMMITED）： √ 表示可能发生，× 表示不会发生 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable read × × √ Serializable × × × 假如有两个事务A和B都在对同一个数据库进行操作： 如果数据库隔离级别设为Read uncommitted，事务A先操作数据库， 修改了一条数据， 但未提交事务，此时事务B读数据库，则会读取到事务A未提交的脏数据，即为脏读； 如果数据库隔离级别设为Read committed， 事务A先操作数据库，读取数据data_a，然后事务B讲数据库中对应的数据修改为data_b并提交事务，此时事务A再去读同一条数据，则数据变为data_b，即不可重复读； 如果数据库隔离级别设为Repeatable read， 事务A先读取某一条件下的一些数据， 然后事务B插入一条数据并提交，而这条数据又恰好满足事务A的select条件，此时事务A再去数据库查询该条件下的数据，发现比上一次多了一条，好像出现幻觉一般，称为幻读； 如果数据库隔离级别设为Serializable，则所有事务都是排着队一条一条执行的，只有上一条事务执行完毕才会开始下一条事务，因而脏读、不可重复读、幻读这些情况都不可能出现。 不可重复读与幻读的区别是，不可重复读是因为修改了数据而造成的数据不一致，幻读是因为插入数据造成的数据不一致。SQL Server 和Oracle默认的隔离级别是Read committedMySQL数据库默认的隔离级别是Repeatable read 数据库锁数据库系统本身的锁机制 ： 共享锁(Shared Lock) S锁允许多个事务同时对同一数据进行读操作，但是不允许修改数据（与X锁冲突）。更新锁(Update Lock) 更新所也称修改锁，事务在更新某一项数据时需要加U锁，读取该数据项，此时允许其他事务在该项上加S锁，待事务读出并修改后，将U锁升级为X锁，然后写入修改后的数据。排他锁(Exclusive Lock)排他锁是独占锁，一般修改数据时使用，select…for update 意向锁(Intent Lock)意向锁是表级锁，说明在资源底层获得共享锁或独占锁的意向。例如，当读取表里的页面时，在请求页共享锁（S锁）之前，事务在表级请求共享意向锁。这样可以防止其他事务随后在表上获取排他锁（X锁），修改整个表格。意向锁可以提高性能，因为数据库引擎仅在表级检查意向锁，确定事务是否能安全地获取该表上的锁，而不需要检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。意向锁有两种用途：防止其他事务以会使较低级别的锁无效的方式修改较高级别资源；提高数据库引擎在较高的粒度级别检测锁冲突的效率。 意向共享锁（IS）表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁 意向排他锁（IX）类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。 各种锁的兼容性如下： 意向共享(IS) 共享(S) 更新(U) 意向排他(IX) 排他(X) 意向共享(IS) 是 是 是 是 否 共享(S) 是 是 是 否 否 更新(U) 是 是 否 否 否 意向排他(IX) 是 否 否 是 否 排他(X) 否 否 否 否 否 模式锁(Schema Lock)Altert table，改变表结构时使用 批量更新锁（Bulk Update Lock）数据库备份恢复 业务级别上的锁机制，hibernate支持有以下两种类型的锁 悲观锁： 对数据被外界修改持保守态度，即认为经常会发生不止一个事务修改同一条数据的情况，因此所有事务对数据修改前都要获取一把锁，用来排斥其他事务对该数据的操作。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能 真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系 统不会修改数据）。如 select * form user where id=#{id} for update;语句，就会使数据库系统锁定该条记录。 乐观锁： 乐观锁认为多个事务并发修改数据库同一条记录这样的情况是不经常发生的，对事务操作加锁也是非必须的，即对此事持乐观态度。但是同样要保证数据的一致性，乐观锁要使用一个标志位来标示是否存在其他事务同时在操作该条数据，这样的标志位大多是基于数据版本（Version）记录机制实现的。 锁的分类(oracle) 按操作划分，可分为DML锁、DDL锁 按锁的粒度划分，可分为表级锁、行级锁、页级锁（mysql） 按锁级别划分，可分为共享锁、排他锁 按加锁方式划分，可分为自动锁、显示锁 按使用方式划分，可分为乐观锁、悲观锁 其他视图（View）数据库视图是一张虚表，逻辑上的表，有时为了区别视图和表，也称表为基本表——Base Table。视图所对应的数据不进行实际存储，不占用物理空间。视图掩码数据库的复杂性，视图把数据库设计的复杂性与用户屏蔽分开，也能起到用户程序与实际数据库表结构解耦的作用。 存储过程存储过程是 SQL 语句和可选控制流语句的预编译集合，以一个名称存储并作为一个单元处理。存储过程存储在数据库内，可由应用程序通过一个调用执行，而且允许用户声明变量、有条件执行以及其它强大的编程功能。 存储过程与函数的区别： 一般情况下，函数实现的功能针对性比较强而存储过程实现的功能要复杂一点。 存储过程来说可以返回参数，而函数只能返回值或者表对象。 一般将存储过程作为一个独立的部分来执行，而把函数作为查询语句的一个部分来调用，由于函数可以返回一个表对象，因此它可以出现在查询语句FROM关键字的后面。 触发器触发器和存储过程一样，也是一段sql程序。不同的是存储过程通过名字直接调用，而触发器则相当于事件监听器，在某个特定的事件发生时由数据库系统自动调用的。 触发器语法：12345create trigger 触发器的名字 on 操作表befor|after instead ofupdate|insert|deleteasSQL语句 在mysql的innoDB引擎下（该引擎下表为事务表），触发器和引起触发器执行的Sql语句具有事务性，如果before类型的触发器执行失败则sql语句不执行，如果sql语句执行失败则after触发器不执行，如果after触发器执行失败则引起触发器执行的sql语句回滚。 游标游标是一个数据缓冲器，也就是一个内存区域，用来暂时存放受SQL语句影响到的数据。即受影响的数据暂时存放在一张虚表中，这个虚表就是游标。 Orale中游标的类型： 隐式游标：在 PL/SQL 程序中执行DML SQL语句时自动创建隐式游标，名字固定叫sql。数据库中的事物可以回滚，而游标在其中起着非常重要的作用，由于对数据库的操作我们会暂时放在游标中，只要不提交，我们就可以根据游标中内容进行回滚，在一定意义有利于数据库的安全。 显式游标：用于从表中取出多行数据,并将多行数据一行一行的单独进行处理. 12345678910declare--1, 声明游标cursor cur isselect * from user;begin--2, 直接使用，Oracle会自动打开和关闭等操作。for v_user in cur loopdbms_output.put_line(v_user.userName);end loopend;]]></content>
      <tags>
        <tag>SQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机中的各种字符集编码]]></title>
    <url>%2F2017%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[作为一个程序员，一个中国的程序员，想来“乱码”问题基本上都遇到过，也为之头疼过。出现乱码问题的根本原因是编码与解码使用了不同而且不兼容的“标准”，在国内一般出现在中文的编解码过程中。 我们平时常见的编码有Unicode，GBK，ASCII，utf8，utf16，ISO8859-1等，弄清这些编码之间的关系，就不难理解“乱码”出现的原因以及解决办法。 所谓字符集编码其实就是将字符（包括英文字符、特殊符号，控制字符，数字，汉子等）与计算机中的一个数字（二进制存储）一一对应起来，用这个数字来表示该字符，存储该字符的时候就存储这个数字。比如a对应数字97。因此，理解编码很简单，所有的编码都是字符与数字的一种对应关系。 ASCII编码：计算机最早出现在美国，因此老美搞编码只需要对26个英文字符大小写以及常用的字符对应数字就可以了，这种对应就是ASCII（American Standard Code for Information Interchange，美国信息互换标准代码）码。标准ASCII 码使用7 位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符。这样可以表示2^7=128个字符。标准ASCII码的最高位恒为0，没有使用。 用java输出英文字符的ASCII码代码如下：123456public class TestCode &#123; public static void main(String[] args) throws Exception &#123; int code='a'; System.out.println(code); &#125;&#125; 输出: 97 ISO8859-1：随着计算机的推广，世界各地都开始使用计算机。各国不同语言对字符编码提出了新的需求，原ASCII的128个字符已经显得严重不足。那怎么办呢，ASCII码不是只用了一个字节中的7位吗，还剩余1位呢？那就赶紧用上吧！于是人们把编码扩展到了8位，即256个字符的编码，这就是ISO8859-1。这种扩展保持了与ASCII的兼容性，即最高位为0的ISO8859-1编码等同于ASCII码。 用java随便输出一个iso8859-1字符如下：123456public class TestCode &#123; public static void main(String[] args) throws Exception &#123; char code=0xA7; System.out.println(code); &#125;&#125; 输出: § GBK码：等到计算机进入中国，人们又头疼了。常用汉字就有6000多个，像ASCII那样用一个字节来编码撑爆了也不够啊。但是这难不倒智慧的中国人们，我们直接定下标准：小于127的字符与原意义相同（保持与ASCII的兼容性），但是两个大于127的字符连在一起时，就表示一个汉字。这样我们就凑出来了7000多个简体汉字的编码了。此外，这些编码还对ASCII码中已有的标点、数字、字母都用两字节重新编码，这就是通常说的“全角”字符。这种编码就是GB2312。 但是中国的汉字实在太多了，GB2312还是不够用，一些不常用的汉字还是显示不出来啊。于是我们不得不继续挖掘GB2312的潜能，干脆只要求第一个字节大于127而不管后一个字节的大小了。这种扩展之后的编码方案称为GBK。 下图为中文“你好”二字的GB2312编码输出（GBK输出相同）：123456789public class TestCode &#123; public static void main(String[] args) throws Exception &#123; String s = "你好"; byte[] code = s.getBytes("gb2312"); for (byte b : code) &#123; System.out.print(Integer.toHexString(b &amp; 0xFF) + " "); &#125; &#125;&#125; 输出: c4 e3 ba c3 Unicode码：中国造出了GBK编码，其他国家呢，他们也要显示自己的文字啊。于是各个国家都搞出了一套自己的编码标准，结果相互之间谁也不懂谁的编码，互不兼容。这样不行啊，于是乎ISO（国际标谁化组织）不得不站出来说话了：“你们都不要各自搞编码了，我给你们搞一套统一的！”。于是ISO搞了一个全球统一的字符集编码方案，叫UCS(Universal Character Set)，俗称Unicode。 Unicode标准最早是1991年发布了，目前实际应用的版本是UCS-2，即使用两个字节编码字符。这样理论上一共可以编码2^16=65536个字符，基本能够满足各种语言的需求。 UTF8、UTF16码：其实Unicode码已经完美解决编码国际化问题了，那utf8和utf16又是神马东东，用来解决什么问题呢？ 前面已经说过，编码只是字符与数字的一种对应关系，这完全是一个数学问题，跟计算机和存储以及网络都没有半毛钱关系。Unicode码就是这样一种对应关系，它并没有涉及到如何存储以及传输的问题。看下面一个例子： 假如某个字符的Unicode编码为0xabcd，也就是两个字节。那存储的时候是哪个字节在前哪个在后呢？网络传输的时候又是先传输哪个字节呢？计算机从文件中读取到0xabcd又是怎么知道这是两个ASCII码还是一个Unicode码呢？ 因此需要一种统一的存储和传输格式来标示Unicode码。这种统一的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）。 编码utf8和utf16就是因此而产生的。 其中utf16与16位的Unicode码完全对应。在Mac和普通PC上，对于字节顺序的理解是不一致的。比如MAC是从低字节开始读取的，因此前文的0xabcd如果按照所见的顺序存储，则会被MAC认为是0xcdab,而windows会从高字节开始读取，得到的是0xabcd，这样根据Unicode码表对应出来的字符就不一致了。 因此，utf16规定使用了大端序（Big-Endian，简写为UTF-16 BE）、 小端序（Little-Endian，简写为UTF-16 LE）以及BOM（byte order mark）的概念。如果在windows上用记事本写上一些中文字符并以Unicode码格式保存，然后使用十六进制查看器打开即可以看到文件的前两个字节为0xfffe(0xfffe在Unicode码中不对应字符),用来标记使用小端序存储（windows平台默认使用小端序）, 下图为中文“你好”二字在windows7上的十六进制数据。 如果用java程序输出“你好”二字的utf16码，则如下：123456789public class TestCode &#123; public static void main(String[] args) throws Exception &#123; String s = "你好"; byte[] code = s.getBytes("utf16"); for (byte b : code) &#123; System.out.print(Integer.toHexString(b &amp; 0xFF) + " "); &#125; &#125;&#125; 输出: fe ff 4f 60 59 7d 可以看到java默认输出的是大端序的utf16编码（BOM为0xfeff）。 由于Unicode统一采用16位二进制编码字符，试想一篇英文文章如果用UTF16来存储的话整整比用ASCII存储多占用一倍的存储空间（英文字符的Unicode码高字节是0），这样白白的浪费让人于心不忍啊。于是utf8诞生了。utf8是一种变长编码，根据不同的Unicode码值采用不同的存储长度。那么问题又来了，既然是变长的系统怎么知道几个字节表示一个字符编码呢？对于这类问题计算机中通用的处理方式就是使用标志位，就像ip段的划分一样。具体如下： 0xxxxxxx,如果是这样的01串,也就是以0开头后面是啥就不用管了XX代表任意bit.就表示把一个字节做为一个单元.就跟ASCII完全一样. 110xxxxx 10xxxxxx.如果是这样的格式,则把两个字节当一个单元 1110xxxx 10xxxxxx 10xxxxxx 如果是这种格式则是三个字节当一个单元. 用java输出“你好”的utf8编码如下：123456789public class TestCode &#123; public static void main(String[] args) throws Exception &#123; String s = "你好"; byte[] code = s.getBytes("utf8"); for (byte b : code) &#123; System.out.print(Integer.toHexString(b &amp; 0xFF) + " "); &#125; &#125;&#125; 输出: e4 bd a0 e5 a5 bd 我们可以跟上面对应一下，“你”字的第一个字节0xe4的高四位二进制是1110，因此这是一个三字节编码，系统识别时就一次读取三个字节再组合成Unicode码数字，然后就可以对应到字符“你”了。字符“好”类似。 Unicode码的发展Unicode码采用16位编码世界字符其实还是有点捉襟见肘的。因此从 Unicode 3.1 版本开始，设立了16个辅助平面（相当于Unicode码又扩充了4位, 2^4=16），使 Unicode 的可使用空间由六万多字增至约一百万字。用白话说就是增加了几个区段，比如原始版本的Unicode码的范围是0x0000 ~ 0xffff， 第一辅助平面的范围是0x10000~0x1FFFD,第二辅助平面的范围是0x20000 ~ 0x2FFFD,…… 最新版的Unicode码规范提出了UCS-4，即使用4字节做Unicode编码。类似前面的utf16，对于UCS-4的Unicode码，可以采用utf32来存储，同样需要定义大小端序和BOM信息。 URLEncodeURL编解码是WEB开发中常用的编解码方法，这种编码不同于上面介绍的几种编码。上文中介绍的编码都是将一个字符对应到一个数字上，而URL编码则是字符替换，将一些非ASCII字符和一些容易引起问题的字符替换为其编码字符，解码时原样替换回来，从而解决url在网络传输中的乱码问题。 看下面一个例子：1234567public class TestUrlCode &#123; public static void main(String[] args) throws Exception &#123; String url="http://www.baidu.com?username=你好"; String encodeStr=java.net.URLEncoder.encode(url, "utf8"); System.out.println(encodeStr); &#125;&#125; 输出： http%3A%2F%2Fwww.baidu.com%3Fusername%3D%E4%BD%A0%E5%A5%BD 我们将原url与编码后的url做一个对比（这里为了让原字符与编码字符对照起来加了一些空格）： http: / / www.baidu.com? username= 你 好http%3A%2F%2Fwww.baidu.com%3Fusername%3D%E4%BD%A0%E5%A5%BD 对比发现，编码后http、www.baidu.com、username这一些并没有改变，：被替换为%3A, /被替换为%2F, ?被替换为%3F,=被替换为%3D, 你好被替换为%E4%BD%A0%E5%A5%BD,这些%后面的十六进制字符都是哪里来的呢，其实就是原字符的utf8码值。前面我们已经看过你好的utf8码为e4 bd a0 e5 a5 bd，这些十六进制转换为字符串形式然后在前面加上% 就是URL编码了。因此解码就是将这些字符串去掉%然后用utf8码译出来 。 常见乱码问题：前文提到，文件保存、网络传输时，所保存和传输的都是字符对应的码值，因此查看文件时必须将这些码值反过来对应到相应的字符（解码），才能形成我们人能够看懂的字符串形式。如果解码时选取的解码方式与编码方式不一致呢，这就是乱码问题的根本原因了。看下面几个例子： 例子1：在中文版的windows系统（本文中使用win7 64位 简体中文旗舰版）桌面上新建txt文件，写上“联通”二字，保存，关闭。然后再双击打开，看到了什么？哇！乱码！ 我们看看windows都做了什么。我们写的“联通”俩字没问题，保存，也就是将这俩字对应出几个数字（码值）保存起来，也没问题。等等，windows是选用哪种编码进行保存的呢？用搜索引擎查一下，原来默认选用ANSI编码，对应在中文版windows系统中就是GBK，我们用十六进制查看器验证一下： 果然是GBK。然后我们将这几个十六进制数字的二进制写出来：1234c1 1100 0001aa 1010 1010cd 1100 1101a8 1010 1000 看第一个字节，以110开头，第二个字节，以10开头，第三个字节，以110开头，第四个字节，以10开头。这不正好符合utf8双字节编码格式吗？因此我们再次双击打开的时候记事本就错误地认为这是utf8编码的文件，这当然的就形成乱码了。 下面使用notepad++打开，同样乱码。然后选择 格式–以ANSI格式编码 瞬间看到亲切的“联通”二字了！ 例子2：做java开发的童鞋经常遇到原Project导入Eclipse乱码问题，如下图（其实这几个乱码的原字符是“你好”二字） 这个就比较简单了，因为原项目采用GBK编码保存的，新导入项目的Eclipse配置的是utf8编码，用utf8来解码读取gbk编码，乱码是必须滴。解决办法就是将两者保持一致即可。 例子 3：有时候编码信息是在文件开始的地方声明的，比如xml文件和html文件，如下： 百度首页的源码精简后摘出一部分源码如下:12345&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf8”/&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 常用的xml文件开头标示如下:1&lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt; 这样的头部标示可以明确地看到文件的编码信息,然而有时候却会引发另一个问题(主要针对开发者): 比如我们写一个html文件:123456&lt;html&gt; &lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt; &lt;body&gt; aaa你好bbb &lt;/body&gt;&lt;/html&gt; 然后在保存这个文件的时候我们不小心选择了GBK编码保存。这样问题就来了，浏览器在读取这个html文件的时候会按照文件中声明的编码utf8的规则读取，这样中文又成乱码了。（因此各位coder要注意文件保存时的编码，遇到类似的问题也要知道原因和解决办法） 例子4：网络流的乱码问题，看下面java小程序socket通信的例子 服务器端123456789101112public class TestSocket &#123; public static void main(String[] args) throws Exception &#123; java.net.ServerSocket ss=new java.net.ServerSocket(7777); java.net.Socket socket=ss.accept(); byte[] buffer=new byte[1024]; int len=socket.getInputStream().read(buffer); String outStr=new String(buffer,0,len,"utf8"); System.out.println(outStr); socket.close(); ss.close(); &#125;&#125; 客户端12345678public class TestSocketClient &#123; public static void main(String[] args) throws Throwable &#123; java.net.Socket client=new java.net.Socket("localhost",7777); String input="你好"; client.getOutputStream().write(input.getBytes("gbk")); client.close(); &#125;&#125; 先启动服务器端，再启动客户端，最后可以看到服务器端输出 这里故意将客户端发送的编码（GBK）与服务器端接收的解码（utf8）设的不一致，出现乱码是必然的。这个错误也是显而易见的。然后并不是所有的通信乱码都是这么明显。比如java中不明确指定编码而使用默认编码，比如使用Reader和Writer对象，这时候编码信息是隐藏的，就不是那么容易发现了。 如果不确定网络中传输的编码，我们可以用wireshark抓个包看看就知道了。由于wireshark抓本地回环包比较麻烦，所以这里我们做实验的时候把客户端程序中的localhost改为百度的ip，把数据包发给百度好了。对应端口也改为80. 首先我们用nslookup命令查看百度域名对应的ip，然后随便选一个（不同地区可能得到的ip不一样，这里选择第一个180.149.132.47来当小白鼠吧） java public class TestSocketClient { public static void main(String[] args) throws Throwable { java.net.Socket client=new java.net.Socket(&quot;180.149.132.47&quot;,80); String input=&quot;你好&quot;; client.getOutputStream().write(input.getBytes(&quot;gbk&quot;)); client.close(); } }java 抓到的数据包如下图，其中10号数据包就是我们程序发出的数据，数据包前面是各种协议的头信息，最后四个字节（c4 e3 ba c3） 才是传输的内容。这4个字节正好是“你好”二字的GBK编码。]]></content>
      <tags>
        <tag>编解码</tag>
        <tag>乱码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题配置]]></title>
    <url>%2F2017%2Fnext%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[用hexo搭建了个人博客，对比了几款主题，最终选定使用排名第一的Next主题。Next主题的最大特点就是简洁干净。看多了各大博客网站的广告块块，再去看Next主题，真是有前一亮的感觉。 配置Next主题的过程中查了不少资料，这里记录一份，以备以后查看，也供其他人参考。 链接记录（更新ing） hexo官方文档(简体中文) Next主题官方文档(简体中文) hexo的next主题个性化配置教程 使用live2d为博客增加卡通人物 live2d效果图 自定义图标库]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>next主题</tag>
      </tags>
  </entry>
</search>
